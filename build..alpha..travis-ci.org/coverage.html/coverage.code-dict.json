{"/home/travis/build/npmtest/node-npmtest-spm/test.js":"/* istanbul instrument in package npmtest_spm */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireExampleJsFromReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - post-init\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - post-init\n    case 'browser':\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-spm/lib.npmtest_spm.js":"/* istanbul instrument in package npmtest_spm */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_spm = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_spm = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-spm/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-spm && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_spm */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_spm\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // post-init\n    // run browser js-env code - post-init\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_spm.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        local.assetsDict['/assets.npmtest_spm.rollup.js'] =\n            local.assetsDict['/assets.npmtest_spm.rollup.js'] ||\n            local.fs.readFileSync(\n                // buildCustomOrg-hack\n                local.npmtest_spm.__dirname +\n                    '/lib.npmtest_spm.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-spm/node_modules/spm/lib/client.js":"var co = require('co');\nvar spmrc = require('spmrc');\nvar client = require('spm-client');\nvar readJSON = require('fs-extra').readJSONSync;\nvar exists = require('fs').existsSync;\n\n// read registry from spm.registry in package.json\nvar registry;\nif (exists('package.json')) {\n  var pkg = readJSON('package.json');\n  var spm = pkg.spm || {};\n  registry = spm.registry;\n}\n\n// load global config from spmrc\nclient.config({\n  registry: registry || spmrc.get('registry'),\n  proxy: spmrc.get('proxy'),\n  auth: spmrc.get('auth'),\n  temp: spmrc.get('user.temp')\n});\n\nexports.config = client.config;\n\nvar methods= [\n  'publish',\n  'unpublish',\n  'login',\n  'install',\n  'info',\n  'search'\n];\n\n// export client api with co wrap\nmethods.forEach(function(method) {\n  exports[method] = co.wrap(client[method]);\n});\n\n\n","/home/travis/build/npmtest/node-npmtest-spm/node_modules/spmrc/index.js":"/*\n * spmrc\n *\n * Thanks to: https://github.com/shockie/node-iniparser\n *\n * An example of ~/.spm/spmrc-3x\n *\n * [user]\n * username=lepture\n *\n * [server:spm]\n * url = https://spmjs.io\n *\n */\n\nvar fs = require('fs');\nvar path = require('path');\n\nvar homedir = process.env.HOME;\nif (!homedir) {\n  homedir = process.env.HOMEDRIVE + process.env.HOMEPATH;\n}\n\n/**\n * Where is your spmrc file.\n */\nexports.spmrcfile = path.join(homedir, '.spm', 'spmrc-3x');\n\n\nvar localrc = path.join(process.cwd(), '.spmrc');\n\nvar tmpdir = process.env.TMPDIR || process.env.TMP || process.env.TEMP;\nif (!tmpdir) {\n  if (process.platform === 'win32') {\n    tmpdir = 'c:\\\\windows\\\\temp';\n  } else {\n    tmpdir = '/tmp';\n  }\n}\n\nvar defaults = {\n  'user.temp': tmpdir,\n  'user.home': homedir,\n  'registry': 'http://spmjs.io',\n  'install.path': 'spm_modules'\n};\n\n\nexports.get = function(key) {\n  var file = exports.spmrcfile;\n  var ret = renderConfig(parse(file));\n  if (fs.existsSync(localrc)) {\n    ret = merge(ret, renderConfig(parse(localrc)));\n  }\n  if (!key) return ret;\n\n  key = key.replace(':', '.');\n  var keys = key.split('.');\n  keys.forEach(function(section) {\n    ret = ret ? ret[section] : null;\n  });\n  if (!ret && defaults[key]) {\n    return defaults[key];\n  }\n  return ret;\n};\n\n\nexports.set = function(key, value) {\n  var file = exports.spmrcfile;\n  var data = parse(file);\n  var keys = key.split('.');\n  var ret;\n\n  if (keys.length === 3) {\n    ret = [];\n    ret.push(keys[0] + ':' + keys[1]);\n    ret.push(keys[2]);\n    keys = ret;\n  }\n  if (keys.length === 2) {\n    data[keys[0]] = data[keys[0]] || {};\n    data[keys[0]][keys[1]] = value;\n  } else if(keys.length === 1) {\n    data[keys[0]] = value;\n  } else {\n    throw new Error('A valid input should be something like user.username=spm');\n  }\n  updateConfig(data);\n  return data;\n};\n\n\n/**\n * Combine set and get into one function.\n */\nexports.config = function(key, value) {\n  if (!value) return exports.get(key);\n  return exports.set(key, value);\n};\n\n\nvar regex = {\n  section: /^\\s*\\[\\s*([^\\]]*)\\s*\\]\\s*$/,\n  param: /^\\s*([\\w\\.\\-\\_]+)\\s*=\\s*(.*?)\\s*$/,\n  comment: /^\\s*;.*$/\n};\nvar _cache = {};\n\n\n/**\n * Parse ini format data.\n */\nfunction parse(file) {\n  file = file || exports.spmrcfile;\n  if (!fs.existsSync(file)) {\n    return {};\n  }\n  var data;\n  if (_cache.hasOwnProperty(file)) {\n    data = _cache[file];\n  } else {\n    data = fs.readFileSync(file, 'utf8');\n    _cache[file] = data;\n  }\n  var value = {};\n  var lines = data.split(/\\r\\n|\\r|\\n/);\n  var section = null;\n  var match;\n  lines.forEach(function(line) {\n    if (regex.comment.test(line)) {\n      return;\n    }\n    if (regex.param.test(line)) {\n      match = line.match(regex.param);\n      if (section) {\n        value[section][match[1]] = match[2];\n      }else {\n        value[match[1]] = match[2];\n      }\n    } else if (regex.section.test(line)) {\n      match = line.match(regex.section);\n      value[match[1]] = {};\n      section = match[1];\n    } else if (line.length === 0 && section) {\n      section = null;\n    }\n  });\n  return value;\n}\nexports.parse = parse;\n\n\nfunction updateConfig(data) {\n  var text = '';\n  var init = true;\n  var file = exports.spmrcfile;\n\n  Object.keys(data).forEach(function(section) {\n    if (!init) {\n      text += '\\n';\n    } else {\n      init = false;\n    }\n    if (typeof data[section] === 'object') {\n      text += '[' + section + ']\\n';\n      Object.keys(data[section]).forEach(function(key) {\n        text += key + ' = ' + data[section][key] + '\\n';\n      });\n    } else {\n      text += section + ' = ' + data[section];\n    }\n  });\n  mkdir(path.dirname(file));\n  fs.writeFileSync(file, text);\n  delete _cache[file];\n}\nexports.write = updateConfig;\n\n\n/**\n * Make config data to objects.\n */\nfunction renderConfig(data) {\n  var ret = {};\n  Object.keys(data).forEach(function(section) {\n    var sections = section.split(':');\n    if (sections.length === 2) {\n      ret[sections[0]] = ret[sections[0]] || {};\n      ret[sections[0]][sections[1]] = data[section];\n    } else {\n      ret[section] = data[section];\n    }\n  });\n  return ret;\n}\n\n\n/**\n * Merge object key values.\n */\nfunction merge(obj) {\n  var target, key;\n\n  for (var i = 1; i < arguments.length; i++) {\n    target = arguments[i];\n    for (key in target) {\n      if (Object.prototype.hasOwnProperty.call(target, key)) {\n        obj[key] = target[key];\n      }\n    }\n  }\n\n  return obj;\n}\n\n\n/**\n * Recursively mkdir. Like `mkdir -r`\n */\nfunction mkdir(dirpath) {\n  if (fs.existsSync(dirpath)) return;\n\n  dirpath.split(/[\\/\\\\]/g).reduce(function(parts, part) {\n    parts += part + '/';\n    var subpath = path.resolve(parts);\n    if (!fs.existsSync(subpath)) {\n      fs.mkdirSync(subpath);\n    }\n    return parts;\n  }, '');\n}\n","/home/travis/build/npmtest/node-npmtest-spm/node_modules/spm-client/index.js":"'use strict';\n\nexports.config = require('./lib/config');\nexports.publish = require('./lib/publish');\nexports.unpublish = require('./lib/unpublish');\nexports.login = require('./lib/login');\nexports.install = require('./lib/install');\nexports.info = require('./lib/info');\nexports.search = require('./lib/search');\n\nexports.util = require('./lib/util');\nexports.tar = require('./lib/tar');\n","/home/travis/build/npmtest/node-npmtest-spm/node_modules/spm-client/lib/config.js":"'use strict';\n\nvar path = require('path');\nvar spmrc = require('spmrc');\nvar debug = require('debug')('spm-client:config');\nvar keys = Object.keys;\n\nvar _config, defaults = {\n  // registry url of yuan server\n  registry: spmrc.get('registry'),\n  // global registry, others are private\n  global_registry: 'http://spmjs.io',\n  // an HTTP proxy, pass to request\n  proxy: spmrc.get('proxy'),\n  // the authKey that copied from spmjs accout page\n  auth: spmrc.get('auth'),\n  // the temp directory\n  temp: spmrc.get('user.temp'),\n  // cache directory\n  cache: path.join(spmrc.get('user.home'), '.spm', 'cache')\n};\n\nmodule.exports = config;\nmodule.exports.reset = reset;\n\n// reset _config first\nreset();\n\nfunction config(obj) {\n  if (!obj) {\n    debug('get %j', _config);\n    return _config;\n  }\n  copy(_config, obj);\n  debug('set %j', _config);\n  return _config;\n}\n\nfunction reset() {\n  _config = {};\n  keys(defaults).forEach(function(key) {\n    _config[key] = defaults[key];\n  });\n}\n\nfunction copy(dest, src) {\n  keys(dest).forEach(function(key) {\n    if (src[key] !== null && src[key] !== undefined) {\n      dest[key] = src[key];\n    }\n  });\n  return dest;\n}\n","/home/travis/build/npmtest/node-npmtest-spm/node_modules/spm-client/node_modules/debug/node.js":"\n/**\n * Module dependencies.\n */\n\nvar tty = require('tty');\nvar util = require('util');\n\n/**\n * This is the Node.js implementation of `debug()`.\n *\n * Expose `debug()` as the module.\n */\n\nexports = module.exports = require('./debug');\nexports.log = log;\nexports.formatArgs = formatArgs;\nexports.save = save;\nexports.load = load;\nexports.useColors = useColors;\n\n/**\n * Colors.\n */\n\nexports.colors = [6, 2, 3, 4, 5, 1];\n\n/**\n * The file descriptor to write the `debug()` calls to.\n * Set the `DEBUG_FD` env variable to override with another value. i.e.:\n *\n *   $ DEBUG_FD=3 node script.js 3>debug.log\n */\n\nvar fd = parseInt(process.env.DEBUG_FD, 10) || 2;\nvar stream = 1 === fd ? process.stdout :\n             2 === fd ? process.stderr :\n             createWritableStdioStream(fd);\n\n/**\n * Is stdout a TTY? Colored output is enabled when `true`.\n */\n\nfunction useColors() {\n  var debugColors = (process.env.DEBUG_COLORS || '').trim().toLowerCase();\n  if (0 === debugColors.length) {\n    return tty.isatty(fd);\n  } else {\n    return '0' !== debugColors\n        && 'no' !== debugColors\n        && 'false' !== debugColors\n        && 'disabled' !== debugColors;\n  }\n}\n\n/**\n * Map %o to `util.inspect()`, since Node doesn't do that out of the box.\n */\n\nvar inspect = (4 === util.inspect.length ?\n  // node <= 0.8.x\n  function (v, colors) {\n    return util.inspect(v, void 0, void 0, colors);\n  } :\n  // node > 0.8.x\n  function (v, colors) {\n    return util.inspect(v, { colors: colors });\n  }\n);\n\nexports.formatters.o = function(v) {\n  return inspect(v, this.useColors)\n    .replace(/\\s*\\n\\s*/g, ' ');\n};\n\n/**\n * Adds ANSI color escape codes if enabled.\n *\n * @api public\n */\n\nfunction formatArgs() {\n  var args = arguments;\n  var useColors = this.useColors;\n  var name = this.namespace;\n\n  if (useColors) {\n    var c = this.color;\n\n    args[0] = '  \\u001b[3' + c + ';1m' + name + ' '\n      + '\\u001b[0m'\n      + args[0] + '\\u001b[3' + c + 'm'\n      + ' +' + exports.humanize(this.diff) + '\\u001b[0m';\n  } else {\n    args[0] = new Date().toUTCString()\n      + ' ' + name + ' ' + args[0];\n  }\n  return args;\n}\n\n/**\n * Invokes `console.error()` with the specified arguments.\n */\n\nfunction log() {\n  return stream.write(util.format.apply(this, arguments) + '\\n');\n}\n\n/**\n * Save `namespaces`.\n *\n * @param {String} namespaces\n * @api private\n */\n\nfunction save(namespaces) {\n  if (null == namespaces) {\n    // If you set a process.env field to null or undefined, it gets cast to the\n    // string 'null' or 'undefined'. Just delete instead.\n    delete process.env.DEBUG;\n  } else {\n    process.env.DEBUG = namespaces;\n  }\n}\n\n/**\n * Load `namespaces`.\n *\n * @return {String} returns the previously persisted debug modes\n * @api private\n */\n\nfunction load() {\n  return process.env.DEBUG;\n}\n\n/**\n * Copied from `node/src/node.js`.\n *\n * XXX: It's lame that node doesn't expose this API out-of-the-box. It also\n * relies on the undocumented `tty_wrap.guessHandleType()` which is also lame.\n */\n\nfunction createWritableStdioStream (fd) {\n  var stream;\n  var tty_wrap = process.binding('tty_wrap');\n\n  // Note stream._type is used for test-module-load-list.js\n\n  switch (tty_wrap.guessHandleType(fd)) {\n    case 'TTY':\n      stream = new tty.WriteStream(fd);\n      stream._type = 'tty';\n\n      // Hack to have stream not keep the event loop alive.\n      // See https://github.com/joyent/node/issues/1726\n      if (stream._handle && stream._handle.unref) {\n        stream._handle.unref();\n      }\n      break;\n\n    case 'FILE':\n      var fs = require('fs');\n      stream = new fs.SyncWriteStream(fd, { autoClose: false });\n      stream._type = 'fs';\n      break;\n\n    case 'PIPE':\n    case 'TCP':\n      var net = require('net');\n      stream = new net.Socket({\n        fd: fd,\n        readable: false,\n        writable: true\n      });\n\n      // FIXME Should probably have an option in net.Socket to create a\n      // stream from an existing fd which is writable only. But for now\n      // we'll just add this hack and set the `readable` member to false.\n      // Test: ./node test/fixtures/echo.js < /etc/passwd\n      stream.readable = false;\n      stream.read = null;\n      stream._type = 'pipe';\n\n      // FIXME Hack to have stream not keep the event loop alive.\n      // See https://github.com/joyent/node/issues/1726\n      if (stream._handle && stream._handle.unref) {\n        stream._handle.unref();\n      }\n      break;\n\n    default:\n      // Probably an error on in uv_guess_handle()\n      throw new Error('Implement me. Unknown stream file type!');\n  }\n\n  // For supporting legacy API we put the FD here.\n  stream.fd = fd;\n\n  stream._isStdio = true;\n\n  return stream;\n}\n\n/**\n * Enable namespaces listed in `process.env.DEBUG` initially.\n */\n\nexports.enable(load());\n","/home/travis/build/npmtest/node-npmtest-spm/node_modules/spm-client/node_modules/debug/debug.js":"\n/**\n * This is the common logic for both the Node.js and web browser\n * implementations of `debug()`.\n *\n * Expose `debug()` as the module.\n */\n\nexports = module.exports = debug;\nexports.coerce = coerce;\nexports.disable = disable;\nexports.enable = enable;\nexports.enabled = enabled;\nexports.humanize = require('ms');\n\n/**\n * The currently active debug mode names, and names to skip.\n */\n\nexports.names = [];\nexports.skips = [];\n\n/**\n * Map of special \"%n\" handling functions, for the debug \"format\" argument.\n *\n * Valid key names are a single, lowercased letter, i.e. \"n\".\n */\n\nexports.formatters = {};\n\n/**\n * Previously assigned color.\n */\n\nvar prevColor = 0;\n\n/**\n * Previous log timestamp.\n */\n\nvar prevTime;\n\n/**\n * Select a color.\n *\n * @return {Number}\n * @api private\n */\n\nfunction selectColor() {\n  return exports.colors[prevColor++ % exports.colors.length];\n}\n\n/**\n * Create a debugger with the given `namespace`.\n *\n * @param {String} namespace\n * @return {Function}\n * @api public\n */\n\nfunction debug(namespace) {\n\n  // define the `disabled` version\n  function disabled() {\n  }\n  disabled.enabled = false;\n\n  // define the `enabled` version\n  function enabled() {\n\n    var self = enabled;\n\n    // set `diff` timestamp\n    var curr = +new Date();\n    var ms = curr - (prevTime || curr);\n    self.diff = ms;\n    self.prev = prevTime;\n    self.curr = curr;\n    prevTime = curr;\n\n    // add the `color` if not set\n    if (null == self.useColors) self.useColors = exports.useColors();\n    if (null == self.color && self.useColors) self.color = selectColor();\n\n    var args = Array.prototype.slice.call(arguments);\n\n    args[0] = exports.coerce(args[0]);\n\n    if ('string' !== typeof args[0]) {\n      // anything else let's inspect with %o\n      args = ['%o'].concat(args);\n    }\n\n    // apply any `formatters` transformations\n    var index = 0;\n    args[0] = args[0].replace(/%([a-z%])/g, function(match, format) {\n      // if we encounter an escaped % then don't increase the array index\n      if (match === '%%') return match;\n      index++;\n      var formatter = exports.formatters[format];\n      if ('function' === typeof formatter) {\n        var val = args[index];\n        match = formatter.call(self, val);\n\n        // now we need to remove `args[index]` since it's inlined in the `format`\n        args.splice(index, 1);\n        index--;\n      }\n      return match;\n    });\n\n    if ('function' === typeof exports.formatArgs) {\n      args = exports.formatArgs.apply(self, args);\n    }\n    var logFn = enabled.log || exports.log || console.log.bind(console);\n    logFn.apply(self, args);\n  }\n  enabled.enabled = true;\n\n  var fn = exports.enabled(namespace) ? enabled : disabled;\n\n  fn.namespace = namespace;\n\n  return fn;\n}\n\n/**\n * Enables a debug mode by namespaces. This can include modes\n * separated by a colon and wildcards.\n *\n * @param {String} namespaces\n * @api public\n */\n\nfunction enable(namespaces) {\n  exports.save(namespaces);\n\n  var split = (namespaces || '').split(/[\\s,]+/);\n  var len = split.length;\n\n  for (var i = 0; i < len; i++) {\n    if (!split[i]) continue; // ignore empty strings\n    namespaces = split[i].replace(/\\*/g, '.*?');\n    if (namespaces[0] === '-') {\n      exports.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));\n    } else {\n      exports.names.push(new RegExp('^' + namespaces + '$'));\n    }\n  }\n}\n\n/**\n * Disable debug output.\n *\n * @api public\n */\n\nfunction disable() {\n  exports.enable('');\n}\n\n/**\n * Returns true if the given mode name is enabled, false otherwise.\n *\n * @param {String} name\n * @return {Boolean}\n * @api public\n */\n\nfunction enabled(name) {\n  var i, len;\n  for (i = 0, len = exports.skips.length; i < len; i++) {\n    if (exports.skips[i].test(name)) {\n      return false;\n    }\n  }\n  for (i = 0, len = exports.names.length; i < len; i++) {\n    if (exports.names[i].test(name)) {\n      return true;\n    }\n  }\n  return false;\n}\n\n/**\n * Coerce `val`.\n *\n * @param {Mixed} val\n * @return {Mixed}\n * @api private\n */\n\nfunction coerce(val) {\n  if (val instanceof Error) return val.stack || val.message;\n  return val;\n}\n","/home/travis/build/npmtest/node-npmtest-spm/node_modules/spm-client/node_modules/ms/index.js":"/**\n * Helpers.\n */\n\nvar s = 1000;\nvar m = s * 60;\nvar h = m * 60;\nvar d = h * 24;\nvar y = d * 365.25;\n\n/**\n * Parse or format the given `val`.\n *\n * Options:\n *\n *  - `long` verbose formatting [false]\n *\n * @param {String|Number} val\n * @param {Object} options\n * @return {String|Number}\n * @api public\n */\n\nmodule.exports = function(val, options){\n  options = options || {};\n  if ('string' == typeof val) return parse(val);\n  return options.long\n    ? long(val)\n    : short(val);\n};\n\n/**\n * Parse the given `str` and return milliseconds.\n *\n * @param {String} str\n * @return {Number}\n * @api private\n */\n\nfunction parse(str) {\n  var match = /^((?:\\d+)?\\.?\\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(str);\n  if (!match) return;\n  var n = parseFloat(match[1]);\n  var type = (match[2] || 'ms').toLowerCase();\n  switch (type) {\n    case 'years':\n    case 'year':\n    case 'yrs':\n    case 'yr':\n    case 'y':\n      return n * y;\n    case 'days':\n    case 'day':\n    case 'd':\n      return n * d;\n    case 'hours':\n    case 'hour':\n    case 'hrs':\n    case 'hr':\n    case 'h':\n      return n * h;\n    case 'minutes':\n    case 'minute':\n    case 'mins':\n    case 'min':\n    case 'm':\n      return n * m;\n    case 'seconds':\n    case 'second':\n    case 'secs':\n    case 'sec':\n    case 's':\n      return n * s;\n    case 'milliseconds':\n    case 'millisecond':\n    case 'msecs':\n    case 'msec':\n    case 'ms':\n      return n;\n  }\n}\n\n/**\n * Short format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction short(ms) {\n  if (ms >= d) return Math.round(ms / d) + 'd';\n  if (ms >= h) return Math.round(ms / h) + 'h';\n  if (ms >= m) return Math.round(ms / m) + 'm';\n  if (ms >= s) return Math.round(ms / s) + 's';\n  return ms + 'ms';\n}\n\n/**\n * Long format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction long(ms) {\n  return plural(ms, d, 'day')\n    || plural(ms, h, 'hour')\n    || plural(ms, m, 'minute')\n    || plural(ms, s, 'second')\n    || ms + ' ms';\n}\n\n/**\n * Pluralization helper.\n */\n\nfunction plural(ms, n, name) {\n  if (ms < n) return;\n  if (ms < n * 1.5) return Math.floor(ms / n) + ' ' + name;\n  return Math.ceil(ms / n) + ' ' + name + 's';\n}\n","/home/travis/build/npmtest/node-npmtest-spm/node_modules/spm-client/lib/publish.js":"'use strict';\n\nvar path = require('path');\nvar join = path.join;\nvar fs = require('fs');\nvar exists = fs.existsSync;\nvar format = require('util').format;\nvar semver = require('semver');\nvar extend = require('extend');\nvar crypto = require('crypto');\nvar log = require('spm-log');\nvar debug = require('debug')('spm-client:publish');\nvar tar = require('./tar');\nvar request = require('./request');\nvar util = require('./util');\n\nvar defaults = {\n  cwd: process.cwd()\n};\n\n/*\n  publish(args, config, callback)\n\n  * args\n    * cwd: where is your package\n    * tag: publish with a given tag that you can install by name@tag, default is stable\n    * force: force publish when the package exists\n  * config: see client.config\n*/\n\nmodule.exports = function* publish(args, config) {\n  args = extend({}, require('./config')(), config, defaults, args);\n  args.cwd = path.resolve(args.cwd);\n\n  log.info('target', args.registry);\n\n  // read package\n  var pkg, pkgPath = join(args.cwd, 'package.json');\n  try {\n    pkg = require(pkgPath);\n  } catch(e) {\n    debug('%s not found', pkgPath);\n  }\n\n  checkPkg(pkg, args);\n\n  if (pkg['private'] === true && args.registry === args.global_registry) {\n    debug('private package %s = %s', args.registry, args.global_registry);\n    throw new Error('it\\'s private package, can\\'t publish to ' + args.registry);\n  }\n\n  pkg.name = pkg.name.toLowerCase();\n  pkg.tag = args.tag || 'stable';\n  pkg.readme = getReadme(args.cwd);\n  pkg.dependencies = getDependencies(pkg);\n\n  args.pkg = pkg;\n  args.url = format('%s/repository/%s/%s/', args.registry, pkg.name, pkg.version);\n\n  debug('publish %s@%s ~ %s', pkg.name, pkg.version, pkg.tag);\n  Object.keys(args).forEach(function(key) {\n    debug('argument %s: %j', key, args[key]);\n  });\n\n  // publish package\n  var req = {};\n  req.force = args.force;\n  req.method = 'POST';\n  req.url = args.url;\n  req.auth = args.auth;\n  req.json = pkg;\n\n  var res = yield* request(req);\n  util.errorHandle(req, res);\n\n  // upload tarfile\n  return yield* upload(args);\n};\n\nfunction* upload(args) {\n  var tarfile = yield createTar(args);\n  var tarbody = fs.readFileSync(tarfile);\n  var tarSize = fs.statSync(tarfile).size;\n  var sizeHuman = (tarSize/1024).toFixed(2) + 'KB';\n  debug('create tarfile %s size is %s', tarfile, sizeHuman);\n  log.info('tarfile', path.basename(tarfile) + ' - ' + sizeHuman);\n  // 2 MB\n  if (tarSize > 2079152) {\n    log.warn('size', 'package is a little big, maybe you need a .spmignore');\n  }\n\n  var req = {};\n  req.force = args.force;\n  req.method = 'PUT';\n  req.url = args.url;\n  req.auth = args.auth;\n  req.body = tarbody;\n  req.headers = {\n    'content-type': 'application/x-tar',\n    'content-encoding': 'gzip',\n    'content-length': tarSize,\n    'x-package-md5': crypto.createHash('md5').update(tarbody).digest('hex')\n  };\n  var res = yield* request(req);\n  try {\n    res.body = JSON.parse(res.body);\n  } catch(e) {}\n  util.errorHandle(req, res);\n  return res.body;\n}\n\nfunction checkPkg(pkg, args) {\n  if (!pkg) {\n    throw new Error('package.json not found');\n  }\n  if (!pkg.name) {\n    throw new Error('name key is missing');\n  }\n  if (!pkg.version) {\n    throw new Error('version key is missing');\n  }\n  if (!util.NAME_REGEX.test(pkg.name)) {\n    throw new Error('name is invalid, should match ' + util.NAME_REGEX.toString());\n  }\n  if (!semver.valid(pkg.version)) {\n    throw new Error('version ' + pkg.version + ' is invalid');\n  }\n  if (!pkg.spm) {\n    throw new Error('spm key is missing');\n  }\n  if (!exists(join(args.cwd, pkg.spm.main || 'index.js'))) {\n    throw new Error('main file is missing');\n  }\n}\n\nfunction getDependencies(pkg) {\n  var deps = pkg.spm.dependencies || {};\n  return Object.keys(deps).map(function(key) {\n    return key + '@' + deps[key];\n  });\n}\n\nfunction createTar(args, noIgnore) {\n  var directory = args.cwd;\n  var pkg = args.pkg;\n  var name = format('%s-%s.tar.gz', pkg.name, pkg.version);\n  var tarfile = join(args.temp, name);\n  return function(callback) {\n    tar.create(directory, tarfile, function(err, target) {\n      if (err) {\n        debug('tar error %s', err.stack);\n        callback(err);\n      }\n      callback(null, target);\n    }, noIgnore);\n  };\n}\n\nfunction getReadme(dir) {\n  var readmeFile = join(dir, 'README.md');\n  return fs.existsSync(readmeFile) ? fs.readFileSync(readmeFile).toString(): '';\n}\n","/home/travis/build/npmtest/node-npmtest-spm/node_modules/spm-client/node_modules/semver/semver.js":"// export the class if we are in a Node-like system.\nif (typeof module === 'object' && module.exports === exports)\n  exports = module.exports = SemVer;\n\n// The debug function is excluded entirely from the minified version.\n/* nomin */ var debug;\n/* nomin */ if (typeof process === 'object' &&\n    /* nomin */ process.env &&\n    /* nomin */ process.env.NODE_DEBUG &&\n    /* nomin */ /\\bsemver\\b/i.test(process.env.NODE_DEBUG))\n  /* nomin */ debug = function() {\n    /* nomin */ var args = Array.prototype.slice.call(arguments, 0);\n    /* nomin */ args.unshift('SEMVER');\n    /* nomin */ console.log.apply(console, args);\n    /* nomin */ };\n/* nomin */ else\n  /* nomin */ debug = function() {};\n\n// Note: this is the semver.org version of the spec that it implements\n// Not necessarily the package version of this code.\nexports.SEMVER_SPEC_VERSION = '2.0.0';\n\n// The actual regexps go on exports.re\nvar re = exports.re = [];\nvar src = exports.src = [];\nvar R = 0;\n\n// The following Regular Expressions can be used for tokenizing,\n// validating, and parsing SemVer version strings.\n\n// ## Numeric Identifier\n// A single `0`, or a non-zero digit followed by zero or more digits.\n\nvar NUMERICIDENTIFIER = R++;\nsrc[NUMERICIDENTIFIER] = '0|[1-9]\\\\d*';\nvar NUMERICIDENTIFIERLOOSE = R++;\nsrc[NUMERICIDENTIFIERLOOSE] = '[0-9]+';\n\n\n// ## Non-numeric Identifier\n// Zero or more digits, followed by a letter or hyphen, and then zero or\n// more letters, digits, or hyphens.\n\nvar NONNUMERICIDENTIFIER = R++;\nsrc[NONNUMERICIDENTIFIER] = '\\\\d*[a-zA-Z-][a-zA-Z0-9-]*';\n\n\n// ## Main Version\n// Three dot-separated numeric identifiers.\n\nvar MAINVERSION = R++;\nsrc[MAINVERSION] = '(' + src[NUMERICIDENTIFIER] + ')\\\\.' +\n                   '(' + src[NUMERICIDENTIFIER] + ')\\\\.' +\n                   '(' + src[NUMERICIDENTIFIER] + ')';\n\nvar MAINVERSIONLOOSE = R++;\nsrc[MAINVERSIONLOOSE] = '(' + src[NUMERICIDENTIFIERLOOSE] + ')\\\\.' +\n                        '(' + src[NUMERICIDENTIFIERLOOSE] + ')\\\\.' +\n                        '(' + src[NUMERICIDENTIFIERLOOSE] + ')';\n\n// ## Pre-release Version Identifier\n// A numeric identifier, or a non-numeric identifier.\n\nvar PRERELEASEIDENTIFIER = R++;\nsrc[PRERELEASEIDENTIFIER] = '(?:' + src[NUMERICIDENTIFIER] +\n                            '|' + src[NONNUMERICIDENTIFIER] + ')';\n\nvar PRERELEASEIDENTIFIERLOOSE = R++;\nsrc[PRERELEASEIDENTIFIERLOOSE] = '(?:' + src[NUMERICIDENTIFIERLOOSE] +\n                                 '|' + src[NONNUMERICIDENTIFIER] + ')';\n\n\n// ## Pre-release Version\n// Hyphen, followed by one or more dot-separated pre-release version\n// identifiers.\n\nvar PRERELEASE = R++;\nsrc[PRERELEASE] = '(?:-(' + src[PRERELEASEIDENTIFIER] +\n                  '(?:\\\\.' + src[PRERELEASEIDENTIFIER] + ')*))';\n\nvar PRERELEASELOOSE = R++;\nsrc[PRERELEASELOOSE] = '(?:-?(' + src[PRERELEASEIDENTIFIERLOOSE] +\n                       '(?:\\\\.' + src[PRERELEASEIDENTIFIERLOOSE] + ')*))';\n\n// ## Build Metadata Identifier\n// Any combination of digits, letters, or hyphens.\n\nvar BUILDIDENTIFIER = R++;\nsrc[BUILDIDENTIFIER] = '[0-9A-Za-z-]+';\n\n// ## Build Metadata\n// Plus sign, followed by one or more period-separated build metadata\n// identifiers.\n\nvar BUILD = R++;\nsrc[BUILD] = '(?:\\\\+(' + src[BUILDIDENTIFIER] +\n             '(?:\\\\.' + src[BUILDIDENTIFIER] + ')*))';\n\n\n// ## Full Version String\n// A main version, followed optionally by a pre-release version and\n// build metadata.\n\n// Note that the only major, minor, patch, and pre-release sections of\n// the version string are capturing groups.  The build metadata is not a\n// capturing group, because it should not ever be used in version\n// comparison.\n\nvar FULL = R++;\nvar FULLPLAIN = 'v?' + src[MAINVERSION] +\n                src[PRERELEASE] + '?' +\n                src[BUILD] + '?';\n\nsrc[FULL] = '^' + FULLPLAIN + '$';\n\n// like full, but allows v1.2.3 and =1.2.3, which people do sometimes.\n// also, 1.0.0alpha1 (prerelease without the hyphen) which is pretty\n// common in the npm registry.\nvar LOOSEPLAIN = '[v=\\\\s]*' + src[MAINVERSIONLOOSE] +\n                 src[PRERELEASELOOSE] + '?' +\n                 src[BUILD] + '?';\n\nvar LOOSE = R++;\nsrc[LOOSE] = '^' + LOOSEPLAIN + '$';\n\nvar GTLT = R++;\nsrc[GTLT] = '((?:<|>)?=?)';\n\n// Something like \"2.*\" or \"1.2.x\".\n// Note that \"x.x\" is a valid xRange identifer, meaning \"any version\"\n// Only the first item is strictly required.\nvar XRANGEIDENTIFIERLOOSE = R++;\nsrc[XRANGEIDENTIFIERLOOSE] = src[NUMERICIDENTIFIERLOOSE] + '|x|X|\\\\*';\nvar XRANGEIDENTIFIER = R++;\nsrc[XRANGEIDENTIFIER] = src[NUMERICIDENTIFIER] + '|x|X|\\\\*';\n\nvar XRANGEPLAIN = R++;\nsrc[XRANGEPLAIN] = '[v=\\\\s]*(' + src[XRANGEIDENTIFIER] + ')' +\n                   '(?:\\\\.(' + src[XRANGEIDENTIFIER] + ')' +\n                   '(?:\\\\.(' + src[XRANGEIDENTIFIER] + ')' +\n                   '(?:' + src[PRERELEASE] + ')?' +\n                   src[BUILD] + '?' +\n                   ')?)?';\n\nvar XRANGEPLAINLOOSE = R++;\nsrc[XRANGEPLAINLOOSE] = '[v=\\\\s]*(' + src[XRANGEIDENTIFIERLOOSE] + ')' +\n                        '(?:\\\\.(' + src[XRANGEIDENTIFIERLOOSE] + ')' +\n                        '(?:\\\\.(' + src[XRANGEIDENTIFIERLOOSE] + ')' +\n                        '(?:' + src[PRERELEASELOOSE] + ')?' +\n                        src[BUILD] + '?' +\n                        ')?)?';\n\nvar XRANGE = R++;\nsrc[XRANGE] = '^' + src[GTLT] + '\\\\s*' + src[XRANGEPLAIN] + '$';\nvar XRANGELOOSE = R++;\nsrc[XRANGELOOSE] = '^' + src[GTLT] + '\\\\s*' + src[XRANGEPLAINLOOSE] + '$';\n\n// Tilde ranges.\n// Meaning is \"reasonably at or greater than\"\nvar LONETILDE = R++;\nsrc[LONETILDE] = '(?:~>?)';\n\nvar TILDETRIM = R++;\nsrc[TILDETRIM] = '(\\\\s*)' + src[LONETILDE] + '\\\\s+';\nre[TILDETRIM] = new RegExp(src[TILDETRIM], 'g');\nvar tildeTrimReplace = '$1~';\n\nvar TILDE = R++;\nsrc[TILDE] = '^' + src[LONETILDE] + src[XRANGEPLAIN] + '$';\nvar TILDELOOSE = R++;\nsrc[TILDELOOSE] = '^' + src[LONETILDE] + src[XRANGEPLAINLOOSE] + '$';\n\n// Caret ranges.\n// Meaning is \"at least and backwards compatible with\"\nvar LONECARET = R++;\nsrc[LONECARET] = '(?:\\\\^)';\n\nvar CARETTRIM = R++;\nsrc[CARETTRIM] = '(\\\\s*)' + src[LONECARET] + '\\\\s+';\nre[CARETTRIM] = new RegExp(src[CARETTRIM], 'g');\nvar caretTrimReplace = '$1^';\n\nvar CARET = R++;\nsrc[CARET] = '^' + src[LONECARET] + src[XRANGEPLAIN] + '$';\nvar CARETLOOSE = R++;\nsrc[CARETLOOSE] = '^' + src[LONECARET] + src[XRANGEPLAINLOOSE] + '$';\n\n// A simple gt/lt/eq thing, or just \"\" to indicate \"any version\"\nvar COMPARATORLOOSE = R++;\nsrc[COMPARATORLOOSE] = '^' + src[GTLT] + '\\\\s*(' + LOOSEPLAIN + ')$|^$';\nvar COMPARATOR = R++;\nsrc[COMPARATOR] = '^' + src[GTLT] + '\\\\s*(' + FULLPLAIN + ')$|^$';\n\n\n// An expression to strip any whitespace between the gtlt and the thing\n// it modifies, so that `> 1.2.3` ==> `>1.2.3`\nvar COMPARATORTRIM = R++;\nsrc[COMPARATORTRIM] = '(\\\\s*)' + src[GTLT] +\n                      '\\\\s*(' + LOOSEPLAIN + '|' + src[XRANGEPLAIN] + ')';\n\n// this one has to use the /g flag\nre[COMPARATORTRIM] = new RegExp(src[COMPARATORTRIM], 'g');\nvar comparatorTrimReplace = '$1$2$3';\n\n\n// Something like `1.2.3 - 1.2.4`\n// Note that these all use the loose form, because they'll be\n// checked against either the strict or loose comparator form\n// later.\nvar HYPHENRANGE = R++;\nsrc[HYPHENRANGE] = '^\\\\s*(' + src[XRANGEPLAIN] + ')' +\n                   '\\\\s+-\\\\s+' +\n                   '(' + src[XRANGEPLAIN] + ')' +\n                   '\\\\s*$';\n\nvar HYPHENRANGELOOSE = R++;\nsrc[HYPHENRANGELOOSE] = '^\\\\s*(' + src[XRANGEPLAINLOOSE] + ')' +\n                        '\\\\s+-\\\\s+' +\n                        '(' + src[XRANGEPLAINLOOSE] + ')' +\n                        '\\\\s*$';\n\n// Star ranges basically just allow anything at all.\nvar STAR = R++;\nsrc[STAR] = '(<|>)?=?\\\\s*\\\\*';\n\n// Compile to actual regexp objects.\n// All are flag-free, unless they were created above with a flag.\nfor (var i = 0; i < R; i++) {\n  debug(i, src[i]);\n  if (!re[i])\n    re[i] = new RegExp(src[i]);\n}\n\nexports.parse = parse;\nfunction parse(version, loose) {\n  var r = loose ? re[LOOSE] : re[FULL];\n  return (r.test(version)) ? new SemVer(version, loose) : null;\n}\n\nexports.valid = valid;\nfunction valid(version, loose) {\n  var v = parse(version, loose);\n  return v ? v.version : null;\n}\n\n\nexports.clean = clean;\nfunction clean(version, loose) {\n  var s = parse(version.trim().replace(/^[=v]+/, ''), loose);\n  return s ? s.version : null;\n}\n\nexports.SemVer = SemVer;\n\nfunction SemVer(version, loose) {\n  if (version instanceof SemVer) {\n    if (version.loose === loose)\n      return version;\n    else\n      version = version.version;\n  } else if (typeof version !== 'string') {\n    throw new TypeError('Invalid Version: ' + version);\n  }\n\n  if (!(this instanceof SemVer))\n    return new SemVer(version, loose);\n\n  debug('SemVer', version, loose);\n  this.loose = loose;\n  var m = version.trim().match(loose ? re[LOOSE] : re[FULL]);\n\n  if (!m)\n    throw new TypeError('Invalid Version: ' + version);\n\n  this.raw = version;\n\n  // these are actually numbers\n  this.major = +m[1];\n  this.minor = +m[2];\n  this.patch = +m[3];\n\n  // numberify any prerelease numeric ids\n  if (!m[4])\n    this.prerelease = [];\n  else\n    this.prerelease = m[4].split('.').map(function(id) {\n      return (/^[0-9]+$/.test(id)) ? +id : id;\n    });\n\n  this.build = m[5] ? m[5].split('.') : [];\n  this.format();\n}\n\nSemVer.prototype.format = function() {\n  this.version = this.major + '.' + this.minor + '.' + this.patch;\n  if (this.prerelease.length)\n    this.version += '-' + this.prerelease.join('.');\n  return this.version;\n};\n\nSemVer.prototype.inspect = function() {\n  return '<SemVer \"' + this + '\">';\n};\n\nSemVer.prototype.toString = function() {\n  return this.version;\n};\n\nSemVer.prototype.compare = function(other) {\n  debug('SemVer.compare', this.version, this.loose, other);\n  if (!(other instanceof SemVer))\n    other = new SemVer(other, this.loose);\n\n  return this.compareMain(other) || this.comparePre(other);\n};\n\nSemVer.prototype.compareMain = function(other) {\n  if (!(other instanceof SemVer))\n    other = new SemVer(other, this.loose);\n\n  return compareIdentifiers(this.major, other.major) ||\n         compareIdentifiers(this.minor, other.minor) ||\n         compareIdentifiers(this.patch, other.patch);\n};\n\nSemVer.prototype.comparePre = function(other) {\n  if (!(other instanceof SemVer))\n    other = new SemVer(other, this.loose);\n\n  // NOT having a prerelease is > having one\n  if (this.prerelease.length && !other.prerelease.length)\n    return -1;\n  else if (!this.prerelease.length && other.prerelease.length)\n    return 1;\n  else if (!this.prerelease.length && !other.prerelease.length)\n    return 0;\n\n  var i = 0;\n  do {\n    var a = this.prerelease[i];\n    var b = other.prerelease[i];\n    debug('prerelease compare', i, a, b);\n    if (a === undefined && b === undefined)\n      return 0;\n    else if (b === undefined)\n      return 1;\n    else if (a === undefined)\n      return -1;\n    else if (a === b)\n      continue;\n    else\n      return compareIdentifiers(a, b);\n  } while (++i);\n};\n\n// preminor will bump the version up to the next minor release, and immediately\n// down to pre-release. premajor and prepatch work the same way.\nSemVer.prototype.inc = function(release, identifier) {\n  switch (release) {\n    case 'premajor':\n      this.prerelease.length = 0;\n      this.patch = 0;\n      this.minor = 0;\n      this.major++;\n      this.inc('pre', identifier);\n      break;\n    case 'preminor':\n      this.prerelease.length = 0;\n      this.patch = 0;\n      this.minor++;\n      this.inc('pre', identifier);\n      break;\n    case 'prepatch':\n      // If this is already a prerelease, it will bump to the next version\n      // drop any prereleases that might already exist, since they are not\n      // relevant at this point.\n      this.prerelease.length = 0;\n      this.inc('patch', identifier);\n      this.inc('pre', identifier);\n      break;\n    // If the input is a non-prerelease version, this acts the same as\n    // prepatch.\n    case 'prerelease':\n      if (this.prerelease.length === 0)\n        this.inc('patch', identifier);\n      this.inc('pre', identifier);\n      break;\n\n    case 'major':\n      // If this is a pre-major version, bump up to the same major version.\n      // Otherwise increment major.\n      // 1.0.0-5 bumps to 1.0.0\n      // 1.1.0 bumps to 2.0.0\n      if (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0)\n        this.major++;\n      this.minor = 0;\n      this.patch = 0;\n      this.prerelease = [];\n      break;\n    case 'minor':\n      // If this is a pre-minor version, bump up to the same minor version.\n      // Otherwise increment minor.\n      // 1.2.0-5 bumps to 1.2.0\n      // 1.2.1 bumps to 1.3.0\n      if (this.patch !== 0 || this.prerelease.length === 0)\n        this.minor++;\n      this.patch = 0;\n      this.prerelease = [];\n      break;\n    case 'patch':\n      // If this is not a pre-release version, it will increment the patch.\n      // If it is a pre-release it will bump up to the same patch version.\n      // 1.2.0-5 patches to 1.2.0\n      // 1.2.0 patches to 1.2.1\n      if (this.prerelease.length === 0)\n        this.patch++;\n      this.prerelease = [];\n      break;\n    // This probably shouldn't be used publicly.\n    // 1.0.0 \"pre\" would become 1.0.0-0 which is the wrong direction.\n    case 'pre':\n      if (this.prerelease.length === 0)\n        this.prerelease = [0];\n      else {\n        var i = this.prerelease.length;\n        while (--i >= 0) {\n          if (typeof this.prerelease[i] === 'number') {\n            this.prerelease[i]++;\n            i = -2;\n          }\n        }\n        if (i === -1) // didn't increment anything\n          this.prerelease.push(0);\n      }\n      if (identifier) {\n        // 1.2.0-beta.1 bumps to 1.2.0-beta.2,\n        // 1.2.0-beta.fooblz or 1.2.0-beta bumps to 1.2.0-beta.0\n        if (this.prerelease[0] === identifier) {\n          if (isNaN(this.prerelease[1]))\n            this.prerelease = [identifier, 0];\n        } else\n          this.prerelease = [identifier, 0];\n      }\n      break;\n\n    default:\n      throw new Error('invalid increment argument: ' + release);\n  }\n  this.format();\n  return this;\n};\n\nexports.inc = inc;\nfunction inc(version, release, loose, identifier) {\n  if (typeof(loose) === 'string') {\n    identifier = loose;\n    loose = undefined;\n  }\n\n  try {\n    return new SemVer(version, loose).inc(release, identifier).version;\n  } catch (er) {\n    return null;\n  }\n}\n\nexports.diff = diff;\nfunction diff(version1, version2) {\n  if (eq(version1, version2)) {\n    return null;\n  } else {\n    var v1 = parse(version1);\n    var v2 = parse(version2);\n    if (v1.prerelease.length || v2.prerelease.length) {\n      for (var key in v1) {\n        if (key === 'major' || key === 'minor' || key === 'patch') {\n          if (v1[key] !== v2[key]) {\n            return 'pre'+key;\n          }\n        }\n      }\n      return 'prerelease';\n    }\n    for (var key in v1) {\n      if (key === 'major' || key === 'minor' || key === 'patch') {\n        if (v1[key] !== v2[key]) {\n          return key;\n        }\n      }\n    }\n  }\n}\n\nexports.compareIdentifiers = compareIdentifiers;\n\nvar numeric = /^[0-9]+$/;\nfunction compareIdentifiers(a, b) {\n  var anum = numeric.test(a);\n  var bnum = numeric.test(b);\n\n  if (anum && bnum) {\n    a = +a;\n    b = +b;\n  }\n\n  return (anum && !bnum) ? -1 :\n         (bnum && !anum) ? 1 :\n         a < b ? -1 :\n         a > b ? 1 :\n         0;\n}\n\nexports.rcompareIdentifiers = rcompareIdentifiers;\nfunction rcompareIdentifiers(a, b) {\n  return compareIdentifiers(b, a);\n}\n\nexports.compare = compare;\nfunction compare(a, b, loose) {\n  return new SemVer(a, loose).compare(b);\n}\n\nexports.compareLoose = compareLoose;\nfunction compareLoose(a, b) {\n  return compare(a, b, true);\n}\n\nexports.rcompare = rcompare;\nfunction rcompare(a, b, loose) {\n  return compare(b, a, loose);\n}\n\nexports.sort = sort;\nfunction sort(list, loose) {\n  return list.sort(function(a, b) {\n    return exports.compare(a, b, loose);\n  });\n}\n\nexports.rsort = rsort;\nfunction rsort(list, loose) {\n  return list.sort(function(a, b) {\n    return exports.rcompare(a, b, loose);\n  });\n}\n\nexports.gt = gt;\nfunction gt(a, b, loose) {\n  return compare(a, b, loose) > 0;\n}\n\nexports.lt = lt;\nfunction lt(a, b, loose) {\n  return compare(a, b, loose) < 0;\n}\n\nexports.eq = eq;\nfunction eq(a, b, loose) {\n  return compare(a, b, loose) === 0;\n}\n\nexports.neq = neq;\nfunction neq(a, b, loose) {\n  return compare(a, b, loose) !== 0;\n}\n\nexports.gte = gte;\nfunction gte(a, b, loose) {\n  return compare(a, b, loose) >= 0;\n}\n\nexports.lte = lte;\nfunction lte(a, b, loose) {\n  return compare(a, b, loose) <= 0;\n}\n\nexports.cmp = cmp;\nfunction cmp(a, op, b, loose) {\n  var ret;\n  switch (op) {\n    case '===':\n      if (typeof a === 'object') a = a.version;\n      if (typeof b === 'object') b = b.version;\n      ret = a === b;\n      break;\n    case '!==':\n      if (typeof a === 'object') a = a.version;\n      if (typeof b === 'object') b = b.version;\n      ret = a !== b;\n      break;\n    case '': case '=': case '==': ret = eq(a, b, loose); break;\n    case '!=': ret = neq(a, b, loose); break;\n    case '>': ret = gt(a, b, loose); break;\n    case '>=': ret = gte(a, b, loose); break;\n    case '<': ret = lt(a, b, loose); break;\n    case '<=': ret = lte(a, b, loose); break;\n    default: throw new TypeError('Invalid operator: ' + op);\n  }\n  return ret;\n}\n\nexports.Comparator = Comparator;\nfunction Comparator(comp, loose) {\n  if (comp instanceof Comparator) {\n    if (comp.loose === loose)\n      return comp;\n    else\n      comp = comp.value;\n  }\n\n  if (!(this instanceof Comparator))\n    return new Comparator(comp, loose);\n\n  debug('comparator', comp, loose);\n  this.loose = loose;\n  this.parse(comp);\n\n  if (this.semver === ANY)\n    this.value = '';\n  else\n    this.value = this.operator + this.semver.version;\n\n  debug('comp', this);\n}\n\nvar ANY = {};\nComparator.prototype.parse = function(comp) {\n  var r = this.loose ? re[COMPARATORLOOSE] : re[COMPARATOR];\n  var m = comp.match(r);\n\n  if (!m)\n    throw new TypeError('Invalid comparator: ' + comp);\n\n  this.operator = m[1];\n  if (this.operator === '=')\n    this.operator = '';\n\n  // if it literally is just '>' or '' then allow anything.\n  if (!m[2])\n    this.semver = ANY;\n  else\n    this.semver = new SemVer(m[2], this.loose);\n};\n\nComparator.prototype.inspect = function() {\n  return '<SemVer Comparator \"' + this + '\">';\n};\n\nComparator.prototype.toString = function() {\n  return this.value;\n};\n\nComparator.prototype.test = function(version) {\n  debug('Comparator.test', version, this.loose);\n\n  if (this.semver === ANY)\n    return true;\n\n  if (typeof version === 'string')\n    version = new SemVer(version, this.loose);\n\n  return cmp(version, this.operator, this.semver, this.loose);\n};\n\n\nexports.Range = Range;\nfunction Range(range, loose) {\n  if ((range instanceof Range) && range.loose === loose)\n    return range;\n\n  if (!(this instanceof Range))\n    return new Range(range, loose);\n\n  this.loose = loose;\n\n  // First, split based on boolean or ||\n  this.raw = range;\n  this.set = range.split(/\\s*\\|\\|\\s*/).map(function(range) {\n    return this.parseRange(range.trim());\n  }, this).filter(function(c) {\n    // throw out any that are not relevant for whatever reason\n    return c.length;\n  });\n\n  if (!this.set.length) {\n    throw new TypeError('Invalid SemVer Range: ' + range);\n  }\n\n  this.format();\n}\n\nRange.prototype.inspect = function() {\n  return '<SemVer Range \"' + this.range + '\">';\n};\n\nRange.prototype.format = function() {\n  this.range = this.set.map(function(comps) {\n    return comps.join(' ').trim();\n  }).join('||').trim();\n  return this.range;\n};\n\nRange.prototype.toString = function() {\n  return this.range;\n};\n\nRange.prototype.parseRange = function(range) {\n  var loose = this.loose;\n  range = range.trim();\n  debug('range', range, loose);\n  // `1.2.3 - 1.2.4` => `>=1.2.3 <=1.2.4`\n  var hr = loose ? re[HYPHENRANGELOOSE] : re[HYPHENRANGE];\n  range = range.replace(hr, hyphenReplace);\n  debug('hyphen replace', range);\n  // `> 1.2.3 < 1.2.5` => `>1.2.3 <1.2.5`\n  range = range.replace(re[COMPARATORTRIM], comparatorTrimReplace);\n  debug('comparator trim', range, re[COMPARATORTRIM]);\n\n  // `~ 1.2.3` => `~1.2.3`\n  range = range.replace(re[TILDETRIM], tildeTrimReplace);\n\n  // `^ 1.2.3` => `^1.2.3`\n  range = range.replace(re[CARETTRIM], caretTrimReplace);\n\n  // normalize spaces\n  range = range.split(/\\s+/).join(' ');\n\n  // At this point, the range is completely trimmed and\n  // ready to be split into comparators.\n\n  var compRe = loose ? re[COMPARATORLOOSE] : re[COMPARATOR];\n  var set = range.split(' ').map(function(comp) {\n    return parseComparator(comp, loose);\n  }).join(' ').split(/\\s+/);\n  if (this.loose) {\n    // in loose mode, throw out any that are not valid comparators\n    set = set.filter(function(comp) {\n      return !!comp.match(compRe);\n    });\n  }\n  set = set.map(function(comp) {\n    return new Comparator(comp, loose);\n  });\n\n  return set;\n};\n\n// Mostly just for testing and legacy API reasons\nexports.toComparators = toComparators;\nfunction toComparators(range, loose) {\n  return new Range(range, loose).set.map(function(comp) {\n    return comp.map(function(c) {\n      return c.value;\n    }).join(' ').trim().split(' ');\n  });\n}\n\n// comprised of xranges, tildes, stars, and gtlt's at this point.\n// already replaced the hyphen ranges\n// turn into a set of JUST comparators.\nfunction parseComparator(comp, loose) {\n  debug('comp', comp);\n  comp = replaceCarets(comp, loose);\n  debug('caret', comp);\n  comp = replaceTildes(comp, loose);\n  debug('tildes', comp);\n  comp = replaceXRanges(comp, loose);\n  debug('xrange', comp);\n  comp = replaceStars(comp, loose);\n  debug('stars', comp);\n  return comp;\n}\n\nfunction isX(id) {\n  return !id || id.toLowerCase() === 'x' || id === '*';\n}\n\n// ~, ~> --> * (any, kinda silly)\n// ~2, ~2.x, ~2.x.x, ~>2, ~>2.x ~>2.x.x --> >=2.0.0 <3.0.0\n// ~2.0, ~2.0.x, ~>2.0, ~>2.0.x --> >=2.0.0 <2.1.0\n// ~1.2, ~1.2.x, ~>1.2, ~>1.2.x --> >=1.2.0 <1.3.0\n// ~1.2.3, ~>1.2.3 --> >=1.2.3 <1.3.0\n// ~1.2.0, ~>1.2.0 --> >=1.2.0 <1.3.0\nfunction replaceTildes(comp, loose) {\n  return comp.trim().split(/\\s+/).map(function(comp) {\n    return replaceTilde(comp, loose);\n  }).join(' ');\n}\n\nfunction replaceTilde(comp, loose) {\n  var r = loose ? re[TILDELOOSE] : re[TILDE];\n  return comp.replace(r, function(_, M, m, p, pr) {\n    debug('tilde', comp, _, M, m, p, pr);\n    var ret;\n\n    if (isX(M))\n      ret = '';\n    else if (isX(m))\n      ret = '>=' + M + '.0.0 <' + (+M + 1) + '.0.0';\n    else if (isX(p))\n      // ~1.2 == >=1.2.0- <1.3.0-\n      ret = '>=' + M + '.' + m + '.0 <' + M + '.' + (+m + 1) + '.0';\n    else if (pr) {\n      debug('replaceTilde pr', pr);\n      if (pr.charAt(0) !== '-')\n        pr = '-' + pr;\n      ret = '>=' + M + '.' + m + '.' + p + pr +\n            ' <' + M + '.' + (+m + 1) + '.0';\n    } else\n      // ~1.2.3 == >=1.2.3 <1.3.0\n      ret = '>=' + M + '.' + m + '.' + p +\n            ' <' + M + '.' + (+m + 1) + '.0';\n\n    debug('tilde return', ret);\n    return ret;\n  });\n}\n\n// ^ --> * (any, kinda silly)\n// ^2, ^2.x, ^2.x.x --> >=2.0.0 <3.0.0\n// ^2.0, ^2.0.x --> >=2.0.0 <3.0.0\n// ^1.2, ^1.2.x --> >=1.2.0 <2.0.0\n// ^1.2.3 --> >=1.2.3 <2.0.0\n// ^1.2.0 --> >=1.2.0 <2.0.0\nfunction replaceCarets(comp, loose) {\n  return comp.trim().split(/\\s+/).map(function(comp) {\n    return replaceCaret(comp, loose);\n  }).join(' ');\n}\n\nfunction replaceCaret(comp, loose) {\n  debug('caret', comp, loose);\n  var r = loose ? re[CARETLOOSE] : re[CARET];\n  return comp.replace(r, function(_, M, m, p, pr) {\n    debug('caret', comp, _, M, m, p, pr);\n    var ret;\n\n    if (isX(M))\n      ret = '';\n    else if (isX(m))\n      ret = '>=' + M + '.0.0 <' + (+M + 1) + '.0.0';\n    else if (isX(p)) {\n      if (M === '0')\n        ret = '>=' + M + '.' + m + '.0 <' + M + '.' + (+m + 1) + '.0';\n      else\n        ret = '>=' + M + '.' + m + '.0 <' + (+M + 1) + '.0.0';\n    } else if (pr) {\n      debug('replaceCaret pr', pr);\n      if (pr.charAt(0) !== '-')\n        pr = '-' + pr;\n      if (M === '0') {\n        if (m === '0')\n          ret = '>=' + M + '.' + m + '.' + p + pr +\n                ' <' + M + '.' + m + '.' + (+p + 1);\n        else\n          ret = '>=' + M + '.' + m + '.' + p + pr +\n                ' <' + M + '.' + (+m + 1) + '.0';\n      } else\n        ret = '>=' + M + '.' + m + '.' + p + pr +\n              ' <' + (+M + 1) + '.0.0';\n    } else {\n      debug('no pr');\n      if (M === '0') {\n        if (m === '0')\n          ret = '>=' + M + '.' + m + '.' + p +\n                ' <' + M + '.' + m + '.' + (+p + 1);\n        else\n          ret = '>=' + M + '.' + m + '.' + p +\n                ' <' + M + '.' + (+m + 1) + '.0';\n      } else\n        ret = '>=' + M + '.' + m + '.' + p +\n              ' <' + (+M + 1) + '.0.0';\n    }\n\n    debug('caret return', ret);\n    return ret;\n  });\n}\n\nfunction replaceXRanges(comp, loose) {\n  debug('replaceXRanges', comp, loose);\n  return comp.split(/\\s+/).map(function(comp) {\n    return replaceXRange(comp, loose);\n  }).join(' ');\n}\n\nfunction replaceXRange(comp, loose) {\n  comp = comp.trim();\n  var r = loose ? re[XRANGELOOSE] : re[XRANGE];\n  return comp.replace(r, function(ret, gtlt, M, m, p, pr) {\n    debug('xRange', comp, ret, gtlt, M, m, p, pr);\n    var xM = isX(M);\n    var xm = xM || isX(m);\n    var xp = xm || isX(p);\n    var anyX = xp;\n\n    if (gtlt === '=' && anyX)\n      gtlt = '';\n\n    if (xM) {\n      if (gtlt === '>' || gtlt === '<') {\n        // nothing is allowed\n        ret = '<0.0.0';\n      } else {\n        // nothing is forbidden\n        ret = '*';\n      }\n    } else if (gtlt && anyX) {\n      // replace X with 0\n      if (xm)\n        m = 0;\n      if (xp)\n        p = 0;\n\n      if (gtlt === '>') {\n        // >1 => >=2.0.0\n        // >1.2 => >=1.3.0\n        // >1.2.3 => >= 1.2.4\n        gtlt = '>=';\n        if (xm) {\n          M = +M + 1;\n          m = 0;\n          p = 0;\n        } else if (xp) {\n          m = +m + 1;\n          p = 0;\n        }\n      } else if (gtlt === '<=') {\n        // <=0.7.x is actually <0.8.0, since any 0.7.x should\n        // pass.  Similarly, <=7.x is actually <8.0.0, etc.\n        gtlt = '<'\n        if (xm)\n          M = +M + 1\n        else\n          m = +m + 1\n      }\n\n      ret = gtlt + M + '.' + m + '.' + p;\n    } else if (xm) {\n      ret = '>=' + M + '.0.0 <' + (+M + 1) + '.0.0';\n    } else if (xp) {\n      ret = '>=' + M + '.' + m + '.0 <' + M + '.' + (+m + 1) + '.0';\n    }\n\n    debug('xRange return', ret);\n\n    return ret;\n  });\n}\n\n// Because * is AND-ed with everything else in the comparator,\n// and '' means \"any version\", just remove the *s entirely.\nfunction replaceStars(comp, loose) {\n  debug('replaceStars', comp, loose);\n  // Looseness is ignored here.  star is always as loose as it gets!\n  return comp.trim().replace(re[STAR], '');\n}\n\n// This function is passed to string.replace(re[HYPHENRANGE])\n// M, m, patch, prerelease, build\n// 1.2 - 3.4.5 => >=1.2.0 <=3.4.5\n// 1.2.3 - 3.4 => >=1.2.0 <3.5.0 Any 3.4.x will do\n// 1.2 - 3.4 => >=1.2.0 <3.5.0\nfunction hyphenReplace($0,\n                       from, fM, fm, fp, fpr, fb,\n                       to, tM, tm, tp, tpr, tb) {\n\n  if (isX(fM))\n    from = '';\n  else if (isX(fm))\n    from = '>=' + fM + '.0.0';\n  else if (isX(fp))\n    from = '>=' + fM + '.' + fm + '.0';\n  else\n    from = '>=' + from;\n\n  if (isX(tM))\n    to = '';\n  else if (isX(tm))\n    to = '<' + (+tM + 1) + '.0.0';\n  else if (isX(tp))\n    to = '<' + tM + '.' + (+tm + 1) + '.0';\n  else if (tpr)\n    to = '<=' + tM + '.' + tm + '.' + tp + '-' + tpr;\n  else\n    to = '<=' + to;\n\n  return (from + ' ' + to).trim();\n}\n\n\n// if ANY of the sets match ALL of its comparators, then pass\nRange.prototype.test = function(version) {\n  if (!version)\n    return false;\n\n  if (typeof version === 'string')\n    version = new SemVer(version, this.loose);\n\n  for (var i = 0; i < this.set.length; i++) {\n    if (testSet(this.set[i], version))\n      return true;\n  }\n  return false;\n};\n\nfunction testSet(set, version) {\n  for (var i = 0; i < set.length; i++) {\n    if (!set[i].test(version))\n      return false;\n  }\n\n  if (version.prerelease.length) {\n    // Find the set of versions that are allowed to have prereleases\n    // For example, ^1.2.3-pr.1 desugars to >=1.2.3-pr.1 <2.0.0\n    // That should allow `1.2.3-pr.2` to pass.\n    // However, `1.2.4-alpha.notready` should NOT be allowed,\n    // even though it's within the range set by the comparators.\n    for (var i = 0; i < set.length; i++) {\n      debug(set[i].semver);\n      if (set[i].semver === ANY)\n        return true;\n\n      if (set[i].semver.prerelease.length > 0) {\n        var allowed = set[i].semver;\n        if (allowed.major === version.major &&\n            allowed.minor === version.minor &&\n            allowed.patch === version.patch)\n          return true;\n      }\n    }\n\n    // Version has a -pre, but it's not one of the ones we like.\n    return false;\n  }\n\n  return true;\n}\n\nexports.satisfies = satisfies;\nfunction satisfies(version, range, loose) {\n  try {\n    range = new Range(range, loose);\n  } catch (er) {\n    return false;\n  }\n  return range.test(version);\n}\n\nexports.maxSatisfying = maxSatisfying;\nfunction maxSatisfying(versions, range, loose) {\n  return versions.filter(function(version) {\n    return satisfies(version, range, loose);\n  }).sort(function(a, b) {\n    return rcompare(a, b, loose);\n  })[0] || null;\n}\n\nexports.validRange = validRange;\nfunction validRange(range, loose) {\n  try {\n    // Return '*' instead of '' so that truthiness works.\n    // This will throw if it's invalid anyway\n    return new Range(range, loose).range || '*';\n  } catch (er) {\n    return null;\n  }\n}\n\n// Determine if version is less than all the versions possible in the range\nexports.ltr = ltr;\nfunction ltr(version, range, loose) {\n  return outside(version, range, '<', loose);\n}\n\n// Determine if version is greater than all the versions possible in the range.\nexports.gtr = gtr;\nfunction gtr(version, range, loose) {\n  return outside(version, range, '>', loose);\n}\n\nexports.outside = outside;\nfunction outside(version, range, hilo, loose) {\n  version = new SemVer(version, loose);\n  range = new Range(range, loose);\n\n  var gtfn, ltefn, ltfn, comp, ecomp;\n  switch (hilo) {\n    case '>':\n      gtfn = gt;\n      ltefn = lte;\n      ltfn = lt;\n      comp = '>';\n      ecomp = '>=';\n      break;\n    case '<':\n      gtfn = lt;\n      ltefn = gte;\n      ltfn = gt;\n      comp = '<';\n      ecomp = '<=';\n      break;\n    default:\n      throw new TypeError('Must provide a hilo val of \"<\" or \">\"');\n  }\n\n  // If it satisifes the range it is not outside\n  if (satisfies(version, range, loose)) {\n    return false;\n  }\n\n  // From now on, variable terms are as if we're in \"gtr\" mode.\n  // but note that everything is flipped for the \"ltr\" function.\n\n  for (var i = 0; i < range.set.length; ++i) {\n    var comparators = range.set[i];\n\n    var high = null;\n    var low = null;\n\n    comparators.forEach(function(comparator) {\n      high = high || comparator;\n      low = low || comparator;\n      if (gtfn(comparator.semver, high.semver, loose)) {\n        high = comparator;\n      } else if (ltfn(comparator.semver, low.semver, loose)) {\n        low = comparator;\n      }\n    });\n\n    // If the edge version comparator has a operator then our version\n    // isn't outside it\n    if (high.operator === comp || high.operator === ecomp) {\n      return false;\n    }\n\n    // If the lowest version comparator has an operator and our version\n    // is less than it then it isn't higher than the range\n    if ((!low.operator || low.operator === comp) &&\n        ltefn(version, low.semver)) {\n      return false;\n    } else if (low.operator === ecomp && ltfn(version, low.semver)) {\n      return false;\n    }\n  }\n  return true;\n}\n\n// Use the define() function if we're in AMD land\nif (typeof define === 'function' && define.amd)\n  define(exports);\n","/home/travis/build/npmtest/node-npmtest-spm/node_modules/spm-log/index.js":"'use strict';\n\nvar util = require('util');\nvar color = require('colorful');\n\nvar log = module.exports = {};\n\nvar levels = {\n  debug: 1,\n  info: 2,\n  warn: 3,\n  error: 4\n};\n\nlog.quiet = false;\nlog.width = 15;\n\nvar SPM_LOG = process.env.SPM_LOG;\nif (SPM_LOG && levels[SPM_LOG.toLowerCase()]) {\n  log.level = SPM_LOG.toLowerCase();\n} else {\n  log.level = 'info';\n}\n\nlog.log = function(level, msg) {\n  if (levels[level] >= levels[log.level] && log.quiet === false) {\n    if (console[level]) {\n      console[level](msg);\n    } else {\n      console.log(msg);\n    }\n  }\n};\n\nlog.debug = function() {\n  var category = arguments[0];\n  var args = Array.prototype.slice.call(arguments).slice(1);\n  var msg = util.format.apply(this, args);\n\n  log.log('debug', getMsg(category, msg, color.blue));\n};\n\nlog.info = function() {\n  var category = arguments[0];\n  var args = Array.prototype.slice.call(arguments).slice(1);\n  var msg = util.format.apply(this, args);\n\n  log.log('info', getMsg(category, msg, color.cyan));\n};\n\nlog.warn = function() {\n  var category = arguments[0];\n  var args = Array.prototype.slice.call(arguments).slice(1);\n  var msg = util.format.apply(this, args);\n\n  log.log('warn', getMsg(category, msg, color.yellow));\n};\n\nlog.error = function() {\n  var category = arguments[0];\n  var args = Array.prototype.slice.call(arguments).slice(1);\n  args = args.map(function(arg) {\n    if (arg.message) {\n      return arg.message;\n    } else if (arg.code) {\n      return arg.code;\n    } else {\n      return arg;\n    }\n  });\n  var msg = util.format.apply(this, args);\n\n  log.log('error', getMsg(category, msg, color.red));\n};\n\nlog.config = function(options) {\n  if (options.verbose) {\n    log.level = 'debug';\n  }\n  if (options.quiet) {\n    log.level = 'warn';\n  }\n  if (options.color === false) {\n    require('colorful').disabled = true;\n    require('colorful').isatty = false;\n  }\n  if (options.color === true) {\n    require('colorful').disabled = false;\n    require('colorful').isatty = true;\n  }\n};\n\n\nfunction getMsg(category, msg, fn) {\n  var len = Math.max(0, log.width - category.length);\n  var pad = new Array(len + 1).join(' ');\n  msg = msg.replace(process.cwd(), '$CWD');\n  msg = msg.replace(process.env.HOME, '~');\n  if (~msg.indexOf('\\x1b[')) {\n    msg = pad + fn(category) + ': ' + msg;\n  } else {\n    msg = pad + fn(category) + ': ' + msg;\n  }\n  return msg;\n}\n","/home/travis/build/npmtest/node-npmtest-spm/node_modules/spm-client/lib/tar.js":"'use strict';\n\n// Thanks to npm.\nvar fstream = require('fstream');\nvar tar = require('tar');\nvar zlib = require('zlib');\nvar path = require('path');\nvar fs = require('fs');\n//var log = require('./log');\n\nexports.create = function(source, target, callback, noIgnore) {\n  function returnError(err) {\n    // don't call the callback multiple times, just return the first error\n    var _callback = callback;\n    callback = function() {};\n    return _callback(err);\n  }\n\n  var fwriter = fstream.Writer({ type: 'File', path: target });\n  fwriter.on('error', function(err) {\n    //log.error('writing', target);\n    return returnError(err);\n  });\n\n  fwriter.on('close', function() {\n    callback(null, target);\n  });\n\n  var pkg = JSON.parse(fs.readFileSync(path.join(source, 'package.json')));\n  var ignoreArray;\n  if (pkg && pkg.spm && pkg.spm.ignore) {\n    ignoreArray = pkg.spm.ignore;\n  } else {\n    ignoreArray = [];\n  }\n  var ignoreFiles = ['.gitignore', '.spmignore'];\n\n  if (noIgnore) {\n    ignoreFiles = [];\n    ignoreArray = ['dist']; // always ignore dist when noIgnore\n  }\n\n  var istream = new Packer({\n    path: source,\n    type: 'Directory',\n    ignoreFiles: ignoreFiles,\n    ignoreArray: ignoreArray,\n    isDirectory: true\n  });\n  istream.on('error', function(err) {\n    //log.error('reading', source);\n    return returnError(err);\n  });\n\n  var packer = tar.Pack({ noProprietary: true });\n  packer.on('error', function(err) {\n    //log.error('creating', target);\n    return returnError(err);\n  });\n\n  var zipper = zlib.Gzip();\n  zipper.on('error', function(err) {\n    //log.error('gzip', target);\n    return returnError(err);\n  });\n\n  istream.pipe(packer).pipe(zipper).pipe(fwriter);\n};\n\n\nvar Ignore = require('fstream-ignore');\nvar inherits = require('inherits');\n\nfunction Packer(props) {\n  if (!(this instanceof Packer)) {\n    return new Packer(props);\n  }\n\n  if (typeof props === 'string') {\n    props = { path: props };\n  }\n\n  props.ignoreFiles = props.ignoreFiles || [];\n  props.ignoreArray = props.ignoreArray || [];\n\n  Ignore.call(this, props);\n  Ignore.prototype.addIgnoreRules.call(this, props.ignoreArray, '');\n\n  this.on('entryStat', function(entry, props) {\n    // files should *always* get into tarballs\n    // in a user-writable state, even if they're\n    // being installed from some wackey vm-mounted\n    // read-only filesystem.\n    entry.mode = props.mode = props.mode | parseInt('0200', 8);\n  });\n}\n\nPacker.prototype.applyIgnores = function(entry, partial, entryObj) {\n\n  // some files are *never* allowed under any circumstances\n  if (entry === '.git' ||\n      entry === '.lock-wscript' ||\n      entry === '.gitignore' ||\n      entry === '.npmignore' ||\n      entry === '.spmignore' ||\n      entry.match(/^\\.wafpickle-[0-9]+$/) ||\n      entry === 'CVS' ||\n      entry === '.svn' ||\n      entry === '.hg' ||\n      entry.match(/^\\..*\\.swp$/) ||\n      entry === '.DS_Store' ||\n      entry.match(/^\\._/)\n    ) {\n    return false;\n  }\n\n  // package.json should be **allways** included\n  if (entry === 'package.json') {\n    return true;\n  }\n\n  return Ignore.prototype.applyIgnores.call(this, entry, partial, entryObj);\n};\n\nPacker.prototype.addIgnoreFiles = function () {\n  var entries = this.entries;\n  // if there's a .spmignore, then we do *not* want to\n  // read the .gitignore.\n  if (-1 !== entries.indexOf('.spmignore')) {\n    var i = entries.indexOf('.gitignore');\n    if (i !== -1) {\n      entries.splice(i, 1);\n    }\n  }\n\n  this.entries = entries;\n\n  Ignore.prototype.addIgnoreFiles.call(this);\n};\n\nPacker.prototype.emitEntry = function(entry) {\n  if (this._paused) {\n    this.once('resume', this.emitEntry.bind(this, entry));\n    return;\n  }\n\n  // skip over symbolic links\n  if (entry.type === 'SymbolicLink') {\n    entry.abort();\n    return;\n  }\n\n  // files in the root directory of the tarball\n  if (entry.type !== 'Directory') {\n    var h = path.dirname((entry.root || entry).path);\n    var t = entry.path.substr(h.length + 1).replace(/^[^\\/\\\\]+/, '');\n    var p = h + '/' + t.replace(/^\\//, '');\n    entry.path = p;\n    entry.dirname = path.dirname(p);\n    return Ignore.prototype.emitEntry.call(this, entry);\n  }\n\n  // don't pack empty directories\n  var me = this;\n  entry.on('entry', function(e) {\n    if (e.parent === entry) {\n      e.parent = me;\n      me.emit('entry', e);\n    }\n  });\n  entry.on('package', this.emit.bind(this, 'package'));\n};\n\ninherits(Packer, Ignore);\n","/home/travis/build/npmtest/node-npmtest-spm/node_modules/spm-client/lib/request.js":"'use strict';\n\nvar os = require('os');\nvar util = require('util');\nvar coRequest = require('co-request');\nvar pkg = require('../package.json');\nvar debug = require('debug')('spm-client:request');\n\nvar userAgent = util.format('spm-client (%s, %s, %s %s)',\n  pkg.version, process.version, os.platform(), os.arch()\n);\n\n/*\n  request(args)\n\n  args will pass to [request](https://github.com/mikeal/request)\n  * special args\n    * auth: has permission to talk with server, found in client.config\n    * force: change force header\n*/\n\nmodule.exports = function* request(args) {\n  args.headers = args.headers || {};\n  args.headers['user-agent'] = userAgent;\n  args.headers['Accept-Language'] = process.env.LANG || 'en_US';\n\n  if (args.auth) {\n    args.headers['Authorization'] = 'Yuan ' + args.auth;\n    // conflict with request\n    delete args.auth;\n  }\n\n  if (args.force) {\n    args.headers['X-Yuan-Force'] = 'true';\n  }\n\n  // always use gzip, and gunzip by request\n  args.gzip = true;\n\n  debug('request %s %s', args.method, args.url);\n  Object.keys(args.headers).forEach(function(key) {\n    debug('header %s: %s', key, args.headers[key]);\n  });\n\n  try {\n    return yield coRequest(args);\n  } catch(err) {\n    if (err.code === 'ECONNREFUSED' || err.code === 'ENOTFOUND') {\n      debug('request error with %s', err.code);\n    }\n    throw err;\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-spm/node_modules/spm-client/lib/util.js":"'use strict';\n\nvar debug = require('debug')('spm-client:util');\n\nvar ID_REGEX = /^([a-z][a-z0-9\\-\\._]*)(?:@(.+))?$/;\nvar NAME_REGEX = /^[a-z][a-z0-9\\-\\._]*$/;\n\nexports.errorHandle = errorHandle;\nexports.resolveid = resolveid;\nexports.ID_REGEX = ID_REGEX;\nexports.NAME_REGEX = NAME_REGEX;\n\nfunction errorHandle(req, res) {\n  var err;\n  if (res.statusCode >= 500) {\n    err = new Error('Server error ~ ' + req.url);\n    err.statusCode = res.statusCode;\n    debug('request %s error: %s, statusCode: %s', req.url, err.message, res.statusCode);\n    throw err;\n  }\n  var body = res.body;\n  if (res.statusCode >= 400) {\n    err = new Error(body.message + ' ~ ' + req.url);\n    err.statusCode = res.statusCode;\n    err.status = body.status;\n    debug('request %s error: %s, statusCode: %s', req.url, err.message, res.statusCode);\n    throw err;\n  }\n}\n\nfunction resolveid(uri) {\n  uri = uri.toLowerCase();\n  var m = uri.match(ID_REGEX);\n  if (!m) return null;\n  return {\n    name: m[1],\n    version: m[2] || ''\n  };\n}\n","/home/travis/build/npmtest/node-npmtest-spm/node_modules/spm-client/lib/unpublish.js":"'use strict';\n\nvar extend = require('extend');\nvar format = require('util').format;\nvar request = require('./request');\nvar util = require('./util');\n\n/*\n  unpublish(args, config)\n\n  * args\n    * name: the package name\n    * version: the package version\n  * config: see client.config\n*/\n\nmodule.exports = function* unpublish(args, config) {\n  args = extend({}, require('./config')(), config, args);\n\n  var req = {};\n  req.url = format('%s/repository/%s/%s', args.registry, args.name,\n    args.version ? args.version + '/' : '');\n  req.method = 'DELETE';\n  req.json = true;\n  req.auth = args.auth;\n\n  var res = yield* request(req);\n  util.errorHandle(req, res);\n  return res.body;\n};\n","/home/travis/build/npmtest/node-npmtest-spm/node_modules/spm-client/lib/login.js":"'use strict';\n\nvar extend = require('extend');\nvar request = require('./request');\nvar util = require('./util');\nvar debug = require('debug')('spm-client:info');\n\n/*\n  login(args, config)\n\n  * args\n    * username: the username of registry\n    * authkey: the authKey that copied from spmjs accout page\n  * config\n*/\n\nmodule.exports = function* login(args, config) {\n  args = extend({}, require('./config')(), config, args);\n\n  if (!(args.authkey && args.username)) {\n    throw new Error('Missing parameters.');\n  }\n\n  var req = {};\n  req.url = args.registry + '/account/login/';\n  req.method = 'POST';\n  req.json = {\n    account: args.username,\n    authkey: args.authkey\n  };\n\n  debug('login %s', args.username);\n  var res = yield* request(req);\n  util.errorHandle(req, res);\n  return res.body;\n};\n","/home/travis/build/npmtest/node-npmtest-spm/node_modules/spm-client/lib/install.js":"'use strict';\n\nvar fs = require('fs');\nvar path = require('path');\nvar crypto = require('crypto');\nvar color = require('colorful');\nvar mkdirp = require('mkdirp');\nvar extend = require('extend');\nvar spmrc = require('spmrc');\nvar log = require('spm-log');\nvar vfs = require('vinyl-fs');\nvar gunzip = require('gulp-gunzip');\nvar untar = require('gulp-untar2');\nvar pipe = require('multipipe');\nvar format = require('util').format;\nvar util = require('./util');\nvar info = require('./info');\nvar request = require('request');\nvar debug = require('debug')('spm-client:install');\nvar getVersion = require('father/lib/util').getVersion;\n\nvar defaults = {\n  cwd: process.cwd(),\n  destination: spmrc.get('install.path')\n};\n\ninstall.installPackage = installPackage;\nmodule.exports = install;\n\n/*\n  install(args, config)\n\n  *args\n    * name: the package name, can also be name@version\n    * cwd: the dependencies of the package in the cwd will be installed, use it when name isn't specified\n    * destination: the directory that install to\n    * force: force download packages from registry, no cache\n    * save: save name to package.dependencies\n    * saveDev: save name to package.devDependencies\n  * config: see client.config\n*/\n\nfunction* install(args, config) {\n  args = extend({}, require('./config')(), config, defaults, args);\n  args.cwd = path.resolve(args.cwd);\n  args.destination = path.join(args.cwd, args.destination);\n  args.downloadlist = {};\n\n  log.info('target', args.registry);\n\n  var packages;\n\n  // spm install id@version\n  if (args.name) {\n    packages = Array.isArray(args.name) ? args.name : [args.name];\n  }\n\n  // spm install\n  else {\n    args.save = false;\n    args.saveDev = false;\n    var pkgPath = path.join(args.cwd, 'package.json');\n    packages = parseDependencies(pkgPath, true);\n  }\n\n  // no package to be installed\n  if (!packages.length) return;\n\n  debug('install packages %s', packages.join(', '));\n  yield packages.map(function(id) {\n    return install.installPackage(id, args, true);\n  });\n\n  log.info('installed', packages.join(', '));\n}\n\n/* Install a package.\n *\n * The process of the installation:\n *\n *  1. Find and download the package from yuan or cache\n *  2. Copy the files to `sea-modules/{name}/{version}/{file}\n */\n\nfunction* installPackage(id, args, saveDeps) {\n  delete args.name;\n  var idObj = util.resolveid(id);\n  idObj.version = idObj.version || 'stable';\n  var pkgId = idObj.name + '@' + (idObj.version);\n  log.debug('install', color.magenta(pkgId));\n  debug('start install package %s', pkgId);\n\n  // The package has downloaded in dest\n  // always false when version is not empty\n  if (existInDest(idObj, args)) {\n    // save dependencies to package.json\n    if ((args.save || args.saveDev) && saveDeps) {\n      save(idObj, args);\n    }\n    return;\n  }\n\n  // Fetch pkg info from registry\n  var pinfo = yield* info(idObj, args);\n  pkgId = pinfo.name + '@' + pinfo.version;\n\n  // The package has been in downloadlist\n  if (pkgId in args.downloadlist) {\n    debug('package %s has been in downloadlist', pkgId);\n    return;\n  }\n\n  args.downloadlist[pkgId] = pinfo;\n\n  // save dependencies to package.json\n  if ((args.save || args.saveDev) && saveDeps) {\n    save(pinfo, args);\n  }\n\n  // The package has downloaded in dest\n  if (existInDest(pinfo, args)) return;\n\n  var dest = path.join(args.destination, pinfo.name, pinfo.version);\n  var filename = pinfo.filename || pinfo.name + '-' + pinfo.version + '.tar.gz';\n  var fileInCache = path.join(args.cache, filename);\n  var fileInRemote = format('%s/repository/%s/%s/%s',\n    args.registry, pinfo.name, pinfo.version, filename);\n  var cacheIsExists = fs.existsSync(fileInCache);\n\n  // download from remote when\n  // 1. force install\n  // 2. cache not exists\n  // 3. cache file is old\n  if (args.force || !(cacheIsExists && md5file(fileInCache) === pinfo.md5)) {\n    debug('cache exists: %s', cacheIsExists);\n    yield download(fileInRemote, fileInCache);\n  }\n\n  // extract from cache\n  yield extract(fileInCache, dest);\n\n  log.debug('installed', color.green(dest));\n  debug('end install package %s', pkgId);\n\n  var packages = parseDependencies(pinfo);\n  if (!packages.length) return;\n\n  log.debug('depends', packages.join(', '));\n  debug('install dependencies %s of packages(%s)', packages.join(', '), pkgId);\n  yield packages.map(function(id) {\n    return installPackage(id, args);\n  });\n}\n\nfunction existInDest(idObj, args) {\n  if (!idObj.version) {\n    return false;\n  }\n\n  var pkgId = format('%s@%s', idObj.name, idObj.version);\n  var dest = path.join(args.destination, idObj.name);\n\n  var ver;\n  try {\n    ver = getVersion(idObj.version, dest);\n  } catch(e) {}\n\n  if (!args.force && ver) {\n    log.debug('found', pkgId);\n    debug('package %s found in %s', pkgId, dest);\n    if (!args.downloadlist[pkgId]) args.downloadlist[pkgId] = idObj;\n    return true;\n  }\n}\n\nfunction download(urlpath, dest) {\n  return function(callback) {\n    log.debug('download', urlpath);\n    debug('download from %s to %s', urlpath, dest);\n    mkdirp.sync(path.dirname(dest));\n    request(urlpath)\n    .once('error', callback)\n    .once('end', callback)\n    .once('close', callback)\n    .pipe(fs.createWriteStream(dest));\n  };\n}\n\nfunction extract(src, dest) {\n  return function(callback) {\n    log.debug('extract', src);\n    debug('extract package from %s to %s', src, dest);\n    pipe(\n      vfs.src(src),\n      gunzip(),\n      untar(),\n      vfs.dest(dest)\n    )\n    .once('error', callback)\n    .once('end', callback)\n    .resume();\n  };\n}\n\nfunction parseDependencies(pkg, includeDev) {\n  if (typeof pkg === 'string') {\n    pkg = readJSON(pkg);\n  }\n\n  var spm = pkg.spm || {};\n  var deps = extend({},\n    includeDev ? spm.engines : {},\n    includeDev ? spm.devDependencies : {},\n    spm.dependencies);\n\n  return Object.keys(deps).map(function(key) {\n    return key + '@' + deps[key];\n  });\n}\n\nfunction save(idObj, args) {\n  var pkgPath = path.join(args.cwd, 'package.json');\n  // https://github.com/spmjs/spm/issues/1183\n  var pkg = fs.existsSync(pkgPath) ? readJSON(pkgPath) : {};\n  var key = args.save ? 'dependencies' : 'devDependencies';\n\n  log.debug('saved', 'in', key, idObj.name + '@' + idObj.version);\n  pkg.spm = pkg.spm || {};\n  pkg.spm[key] = pkg.spm[key] || {};\n  pkg.spm[key][idObj.name] = '~' + idObj.version;\n\n  fs.writeFileSync(pkgPath, JSON.stringify(pkg, null, 2));\n}\n\nfunction md5file(fpath) {\n  var md5 = crypto.createHash('md5');\n  return md5.update(fs.readFileSync(fpath)).digest('hex');\n}\n\nfunction readJSON(filepath) {\n  var code = fs.readFileSync(filepath).toString();\n  return JSON.parse(code);\n}\n","/home/travis/build/npmtest/node-npmtest-spm/node_modules/spm-client/lib/info.js":"'use strict';\n\nvar extend = require('extend');\nvar format = require('util').format;\nvar request = require('./request');\nvar util = require('./util');\nvar debug = require('debug')('spm-client:info');\nvar semver = require('semver');\n\n/*\n  info(args, config)\n\n  * args\n    * name: the package name\n    * version: the package version\n  * config: see client.config\n*/\n\nmodule.exports = function* info(args, config) {\n  args = extend({}, require('./config')(), config, args);\n\n  // name@tag\n  if (args.version && args.version.indexOf('.') === -1 && args.version.indexOf('*') === -1) {\n    args.tag = args.version;\n    delete args.version;\n  }\n\n  var req = {};\n  if (args.version) {\n    req.url = format('%s/repository/%s/%s/', args.registry, args.name, args.version);\n  } else {\n    req.url = format('%s/repository/%s/', args.registry, args.name);\n  }\n  req.method = 'GET';\n  req.json = true;\n\n  debug('get package info %s@%s~%s url %s',\n    args.name, args.version || '-', args.tag || '-', req.url);\n  var res = yield* request(req);\n\n  util.errorHandle(req, res);\n\n  var body = args.tag ? getPackageWithTag(res.body, args) : getPackage(res.body, args);\n  if (!body) {\n    var err = new Error('no matched package ' + args.name + (args.tag ? ' ~ ' + args.tag : ''));\n    err.statusCode = res.statusCode;\n    throw err;\n  }\n  debug('response body %j', body);\n  return body;\n};\n\nfunction getPackageWithTag(body, args) {\n  var version = Object.keys(body.packages)\n  .filter(function(version) {\n    return body.packages[version].tag === args.tag;\n  })\n  .sort(function(a, b){\n    return semver.lt(a, b) ? 1 : -1;\n  })[0];\n  if (!version) return null;\n  return body.packages[version];\n}\n\nfunction getPackage(body, args) {\n  if (!body.packages) return body;\n  if (args.version) {\n    debug('get package version %s', args.version);\n    return body.packages[args.version];\n  } else {\n    return body;\n  }\n}\n","/home/travis/build/npmtest/node-npmtest-spm/node_modules/spm-client/node_modules/father/lib/util.js":"'use strict';\n\nvar fs = require('fs');\nvar semver = require('semver');\nvar path = require('path');\nvar join = path.join;\nvar exists = fs.existsSync;\nvar dirname = path.dirname;\n\nexports.getVersion = getVersion;\nexports.getBase = getBase;\nexports.resolvePath = resolvePath;\nexports.isRelative = isRelative;\nexports.winPath = winPath;\n\nfunction getVersion(version, dest) {\n  if (!exists(dest)) return;\n\n  var map = {};\n  var dirs = fs.readdirSync(dest);\n  var versions = dirs\n    .filter(filterDir)\n    .map(getPkgVersion)\n    .filter(semver.valid)\n    .sort(semver.rcompare);\n  var ret = semver.maxSatisfying(versions, version);\n  if (ret) {\n    return {\n      version: ret,\n      dir: map[ret]\n    };\n  }\n\n  // match reference for component\n  // tag, branch, hash\n  //  dirs.some(function(ver) {\n  //    if (!semver.valid(ver) && ver === version) {\n  //      ret = ver;\n  //      return true;\n  //    }\n  //  });\n  return ret;\n\n  function getPkgVersion(dir) {\n    var pkg = join(dest, dir, 'package.json');\n    var ver = require(pkg).version;\n    map[ver] = dir;\n    return ver;\n  }\n\n  function filterDir(dir) {\n    return fs.statSync(join(dest, dir)).isDirectory();\n  }\n}\n\nfunction getBase(pkg) {\n  while(pkg.father) {\n    pkg = pkg.father;\n  }\n  return pkg.dest;\n}\n\n/*\n  resolve a `relative` path base on `base` path\n*/\n\nfunction resolvePath(relative, base) {\n  if (!isRelative(relative) || !base) return relative;\n  relative = join(dirname(base), relative);\n  if (isRelative(relative)) throw new Error(winPath(relative) + ' is out of bound');\n  return relative;\n}\n\n/*\n  Test filepath is relative path or not\n*/\n\nfunction isRelative(filepath) {\n  return filepath.charAt(0) === '.';\n}\n\nfunction winPath(path) {\n  return path.replace(/\\\\/g, '/');\n}\n","/home/travis/build/npmtest/node-npmtest-spm/node_modules/spm-client/node_modules/father/node_modules/semver/semver.js":"// export the class if we are in a Node-like system.\nif (typeof module === 'object' && module.exports === exports)\n  exports = module.exports = SemVer;\n\n// The debug function is excluded entirely from the minified version.\n/* nomin */ var debug;\n/* nomin */ if (typeof process === 'object' &&\n    /* nomin */ process.env &&\n    /* nomin */ process.env.NODE_DEBUG &&\n    /* nomin */ /\\bsemver\\b/i.test(process.env.NODE_DEBUG))\n  /* nomin */ debug = function() {\n    /* nomin */ var args = Array.prototype.slice.call(arguments, 0);\n    /* nomin */ args.unshift('SEMVER');\n    /* nomin */ console.log.apply(console, args);\n    /* nomin */ };\n/* nomin */ else\n  /* nomin */ debug = function() {};\n\n// Note: this is the semver.org version of the spec that it implements\n// Not necessarily the package version of this code.\nexports.SEMVER_SPEC_VERSION = '2.0.0';\n\n// The actual regexps go on exports.re\nvar re = exports.re = [];\nvar src = exports.src = [];\nvar R = 0;\n\n// The following Regular Expressions can be used for tokenizing,\n// validating, and parsing SemVer version strings.\n\n// ## Numeric Identifier\n// A single `0`, or a non-zero digit followed by zero or more digits.\n\nvar NUMERICIDENTIFIER = R++;\nsrc[NUMERICIDENTIFIER] = '0|[1-9]\\\\d*';\nvar NUMERICIDENTIFIERLOOSE = R++;\nsrc[NUMERICIDENTIFIERLOOSE] = '[0-9]+';\n\n\n// ## Non-numeric Identifier\n// Zero or more digits, followed by a letter or hyphen, and then zero or\n// more letters, digits, or hyphens.\n\nvar NONNUMERICIDENTIFIER = R++;\nsrc[NONNUMERICIDENTIFIER] = '\\\\d*[a-zA-Z-][a-zA-Z0-9-]*';\n\n\n// ## Main Version\n// Three dot-separated numeric identifiers.\n\nvar MAINVERSION = R++;\nsrc[MAINVERSION] = '(' + src[NUMERICIDENTIFIER] + ')\\\\.' +\n                   '(' + src[NUMERICIDENTIFIER] + ')\\\\.' +\n                   '(' + src[NUMERICIDENTIFIER] + ')';\n\nvar MAINVERSIONLOOSE = R++;\nsrc[MAINVERSIONLOOSE] = '(' + src[NUMERICIDENTIFIERLOOSE] + ')\\\\.' +\n                        '(' + src[NUMERICIDENTIFIERLOOSE] + ')\\\\.' +\n                        '(' + src[NUMERICIDENTIFIERLOOSE] + ')';\n\n// ## Pre-release Version Identifier\n// A numeric identifier, or a non-numeric identifier.\n\nvar PRERELEASEIDENTIFIER = R++;\nsrc[PRERELEASEIDENTIFIER] = '(?:' + src[NUMERICIDENTIFIER] +\n                            '|' + src[NONNUMERICIDENTIFIER] + ')';\n\nvar PRERELEASEIDENTIFIERLOOSE = R++;\nsrc[PRERELEASEIDENTIFIERLOOSE] = '(?:' + src[NUMERICIDENTIFIERLOOSE] +\n                                 '|' + src[NONNUMERICIDENTIFIER] + ')';\n\n\n// ## Pre-release Version\n// Hyphen, followed by one or more dot-separated pre-release version\n// identifiers.\n\nvar PRERELEASE = R++;\nsrc[PRERELEASE] = '(?:-(' + src[PRERELEASEIDENTIFIER] +\n                  '(?:\\\\.' + src[PRERELEASEIDENTIFIER] + ')*))';\n\nvar PRERELEASELOOSE = R++;\nsrc[PRERELEASELOOSE] = '(?:-?(' + src[PRERELEASEIDENTIFIERLOOSE] +\n                       '(?:\\\\.' + src[PRERELEASEIDENTIFIERLOOSE] + ')*))';\n\n// ## Build Metadata Identifier\n// Any combination of digits, letters, or hyphens.\n\nvar BUILDIDENTIFIER = R++;\nsrc[BUILDIDENTIFIER] = '[0-9A-Za-z-]+';\n\n// ## Build Metadata\n// Plus sign, followed by one or more period-separated build metadata\n// identifiers.\n\nvar BUILD = R++;\nsrc[BUILD] = '(?:\\\\+(' + src[BUILDIDENTIFIER] +\n             '(?:\\\\.' + src[BUILDIDENTIFIER] + ')*))';\n\n\n// ## Full Version String\n// A main version, followed optionally by a pre-release version and\n// build metadata.\n\n// Note that the only major, minor, patch, and pre-release sections of\n// the version string are capturing groups.  The build metadata is not a\n// capturing group, because it should not ever be used in version\n// comparison.\n\nvar FULL = R++;\nvar FULLPLAIN = 'v?' + src[MAINVERSION] +\n                src[PRERELEASE] + '?' +\n                src[BUILD] + '?';\n\nsrc[FULL] = '^' + FULLPLAIN + '$';\n\n// like full, but allows v1.2.3 and =1.2.3, which people do sometimes.\n// also, 1.0.0alpha1 (prerelease without the hyphen) which is pretty\n// common in the npm registry.\nvar LOOSEPLAIN = '[v=\\\\s]*' + src[MAINVERSIONLOOSE] +\n                 src[PRERELEASELOOSE] + '?' +\n                 src[BUILD] + '?';\n\nvar LOOSE = R++;\nsrc[LOOSE] = '^' + LOOSEPLAIN + '$';\n\nvar GTLT = R++;\nsrc[GTLT] = '((?:<|>)?=?)';\n\n// Something like \"2.*\" or \"1.2.x\".\n// Note that \"x.x\" is a valid xRange identifer, meaning \"any version\"\n// Only the first item is strictly required.\nvar XRANGEIDENTIFIERLOOSE = R++;\nsrc[XRANGEIDENTIFIERLOOSE] = src[NUMERICIDENTIFIERLOOSE] + '|x|X|\\\\*';\nvar XRANGEIDENTIFIER = R++;\nsrc[XRANGEIDENTIFIER] = src[NUMERICIDENTIFIER] + '|x|X|\\\\*';\n\nvar XRANGEPLAIN = R++;\nsrc[XRANGEPLAIN] = '[v=\\\\s]*(' + src[XRANGEIDENTIFIER] + ')' +\n                   '(?:\\\\.(' + src[XRANGEIDENTIFIER] + ')' +\n                   '(?:\\\\.(' + src[XRANGEIDENTIFIER] + ')' +\n                   '(?:(' + src[PRERELEASE] + ')' +\n                   ')?)?)?';\n\nvar XRANGEPLAINLOOSE = R++;\nsrc[XRANGEPLAINLOOSE] = '[v=\\\\s]*(' + src[XRANGEIDENTIFIERLOOSE] + ')' +\n                        '(?:\\\\.(' + src[XRANGEIDENTIFIERLOOSE] + ')' +\n                        '(?:\\\\.(' + src[XRANGEIDENTIFIERLOOSE] + ')' +\n                        '(?:(' + src[PRERELEASELOOSE] + ')' +\n                        ')?)?)?';\n\n// >=2.x, for example, means >=2.0.0-0\n// <1.x would be the same as \"<1.0.0-0\", though.\nvar XRANGE = R++;\nsrc[XRANGE] = '^' + src[GTLT] + '\\\\s*' + src[XRANGEPLAIN] + '$';\nvar XRANGELOOSE = R++;\nsrc[XRANGELOOSE] = '^' + src[GTLT] + '\\\\s*' + src[XRANGEPLAINLOOSE] + '$';\n\n// Tilde ranges.\n// Meaning is \"reasonably at or greater than\"\nvar LONETILDE = R++;\nsrc[LONETILDE] = '(?:~>?)';\n\nvar TILDETRIM = R++;\nsrc[TILDETRIM] = '(\\\\s*)' + src[LONETILDE] + '\\\\s+';\nre[TILDETRIM] = new RegExp(src[TILDETRIM], 'g');\nvar tildeTrimReplace = '$1~';\n\nvar TILDE = R++;\nsrc[TILDE] = '^' + src[LONETILDE] + src[XRANGEPLAIN] + '$';\nvar TILDELOOSE = R++;\nsrc[TILDELOOSE] = '^' + src[LONETILDE] + src[XRANGEPLAINLOOSE] + '$';\n\n// Caret ranges.\n// Meaning is \"at least and backwards compatible with\"\nvar LONECARET = R++;\nsrc[LONECARET] = '(?:\\\\^)';\n\nvar CARETTRIM = R++;\nsrc[CARETTRIM] = '(\\\\s*)' + src[LONECARET] + '\\\\s+';\nre[CARETTRIM] = new RegExp(src[CARETTRIM], 'g');\nvar caretTrimReplace = '$1^';\n\nvar CARET = R++;\nsrc[CARET] = '^' + src[LONECARET] + src[XRANGEPLAIN] + '$';\nvar CARETLOOSE = R++;\nsrc[CARETLOOSE] = '^' + src[LONECARET] + src[XRANGEPLAINLOOSE] + '$';\n\n// A simple gt/lt/eq thing, or just \"\" to indicate \"any version\"\nvar COMPARATORLOOSE = R++;\nsrc[COMPARATORLOOSE] = '^' + src[GTLT] + '\\\\s*(' + LOOSEPLAIN + ')$|^$';\nvar COMPARATOR = R++;\nsrc[COMPARATOR] = '^' + src[GTLT] + '\\\\s*(' + FULLPLAIN + ')$|^$';\n\n\n// An expression to strip any whitespace between the gtlt and the thing\n// it modifies, so that `> 1.2.3` ==> `>1.2.3`\nvar COMPARATORTRIM = R++;\nsrc[COMPARATORTRIM] = '(\\\\s*)' + src[GTLT] +\n                      '\\\\s*(' + LOOSEPLAIN + '|' + src[XRANGEPLAIN] + ')';\n\n// this one has to use the /g flag\nre[COMPARATORTRIM] = new RegExp(src[COMPARATORTRIM], 'g');\nvar comparatorTrimReplace = '$1$2$3';\n\n\n// Something like `1.2.3 - 1.2.4`\n// Note that these all use the loose form, because they'll be\n// checked against either the strict or loose comparator form\n// later.\nvar HYPHENRANGE = R++;\nsrc[HYPHENRANGE] = '^\\\\s*(' + src[XRANGEPLAIN] + ')' +\n                   '\\\\s+-\\\\s+' +\n                   '(' + src[XRANGEPLAIN] + ')' +\n                   '\\\\s*$';\n\nvar HYPHENRANGELOOSE = R++;\nsrc[HYPHENRANGELOOSE] = '^\\\\s*(' + src[XRANGEPLAINLOOSE] + ')' +\n                        '\\\\s+-\\\\s+' +\n                        '(' + src[XRANGEPLAINLOOSE] + ')' +\n                        '\\\\s*$';\n\n// Star ranges basically just allow anything at all.\nvar STAR = R++;\nsrc[STAR] = '(<|>)?=?\\\\s*\\\\*';\n\n// Compile to actual regexp objects.\n// All are flag-free, unless they were created above with a flag.\nfor (var i = 0; i < R; i++) {\n  debug(i, src[i]);\n  if (!re[i])\n    re[i] = new RegExp(src[i]);\n}\n\nexports.parse = parse;\nfunction parse(version, loose) {\n  var r = loose ? re[LOOSE] : re[FULL];\n  return (r.test(version)) ? new SemVer(version, loose) : null;\n}\n\nexports.valid = valid;\nfunction valid(version, loose) {\n  var v = parse(version, loose);\n  return v ? v.version : null;\n}\n\n\nexports.clean = clean;\nfunction clean(version, loose) {\n  var s = parse(version, loose);\n  return s ? s.version : null;\n}\n\nexports.SemVer = SemVer;\n\nfunction SemVer(version, loose) {\n  if (version instanceof SemVer) {\n    if (version.loose === loose)\n      return version;\n    else\n      version = version.version;\n  } else if (typeof version !== 'string') {\n    throw new TypeError('Invalid Version: ' + version);\n  }\n\n  if (!(this instanceof SemVer))\n    return new SemVer(version, loose);\n\n  debug('SemVer', version, loose);\n  this.loose = loose;\n  var m = version.trim().match(loose ? re[LOOSE] : re[FULL]);\n\n  if (!m)\n    throw new TypeError('Invalid Version: ' + version);\n\n  this.raw = version;\n\n  // these are actually numbers\n  this.major = +m[1];\n  this.minor = +m[2];\n  this.patch = +m[3];\n\n  // numberify any prerelease numeric ids\n  if (!m[4])\n    this.prerelease = [];\n  else\n    this.prerelease = m[4].split('.').map(function(id) {\n      return (/^[0-9]+$/.test(id)) ? +id : id;\n    });\n\n  this.build = m[5] ? m[5].split('.') : [];\n  this.format();\n}\n\nSemVer.prototype.format = function() {\n  this.version = this.major + '.' + this.minor + '.' + this.patch;\n  if (this.prerelease.length)\n    this.version += '-' + this.prerelease.join('.');\n  return this.version;\n};\n\nSemVer.prototype.inspect = function() {\n  return '<SemVer \"' + this + '\">';\n};\n\nSemVer.prototype.toString = function() {\n  return this.version;\n};\n\nSemVer.prototype.compare = function(other) {\n  debug('SemVer.compare', this.version, this.loose, other);\n  if (!(other instanceof SemVer))\n    other = new SemVer(other, this.loose);\n\n  return this.compareMain(other) || this.comparePre(other);\n};\n\nSemVer.prototype.compareMain = function(other) {\n  if (!(other instanceof SemVer))\n    other = new SemVer(other, this.loose);\n\n  return compareIdentifiers(this.major, other.major) ||\n         compareIdentifiers(this.minor, other.minor) ||\n         compareIdentifiers(this.patch, other.patch);\n};\n\nSemVer.prototype.comparePre = function(other) {\n  if (!(other instanceof SemVer))\n    other = new SemVer(other, this.loose);\n\n  // NOT having a prerelease is > having one\n  if (this.prerelease.length && !other.prerelease.length)\n    return -1;\n  else if (!this.prerelease.length && other.prerelease.length)\n    return 1;\n  else if (!this.prerelease.length && !other.prerelease.length)\n    return 0;\n\n  var i = 0;\n  do {\n    var a = this.prerelease[i];\n    var b = other.prerelease[i];\n    debug('prerelease compare', i, a, b);\n    if (a === undefined && b === undefined)\n      return 0;\n    else if (b === undefined)\n      return 1;\n    else if (a === undefined)\n      return -1;\n    else if (a === b)\n      continue;\n    else\n      return compareIdentifiers(a, b);\n  } while (++i);\n};\n\n// preminor will bump the version up to the next minor release, and immediately\n// down to pre-release. premajor and prepatch work the same way.\nSemVer.prototype.inc = function(release) {\n  switch (release) {\n    case 'premajor':\n      this.inc('major');\n      this.inc('pre');\n      break;\n    case 'preminor':\n      this.inc('minor');\n      this.inc('pre');\n      break;\n    case 'prepatch':\n      // If this is already a prerelease, it will bump to the next version\n      // drop any prereleases that might already exist, since they are not\n      // relevant at this point.\n      this.prerelease.length = 0\n      this.inc('patch');\n      this.inc('pre');\n      break;\n    // If the input is a non-prerelease version, this acts the same as\n    // prepatch.\n    case 'prerelease':\n      if (this.prerelease.length === 0)\n        this.inc('patch');\n      this.inc('pre');\n      break;\n    case 'major':\n      this.major++;\n      this.minor = -1;\n    case 'minor':\n      this.minor++;\n      this.patch = 0;\n      this.prerelease = [];\n      break;\n    case 'patch':\n      // If this is not a pre-release version, it will increment the patch.\n      // If it is a pre-release it will bump up to the same patch version.\n      // 1.2.0-5 patches to 1.2.0\n      // 1.2.0 patches to 1.2.1\n      if (this.prerelease.length === 0)\n        this.patch++;\n      this.prerelease = [];\n      break;\n    // This probably shouldn't be used publically.\n    // 1.0.0 \"pre\" would become 1.0.0-0 which is the wrong direction.\n    case 'pre':\n      if (this.prerelease.length === 0)\n        this.prerelease = [0];\n      else {\n        var i = this.prerelease.length;\n        while (--i >= 0) {\n          if (typeof this.prerelease[i] === 'number') {\n            this.prerelease[i]++;\n            i = -2;\n          }\n        }\n        if (i === -1) // didn't increment anything\n          this.prerelease.push(0);\n      }\n      break;\n\n    default:\n      throw new Error('invalid increment argument: ' + release);\n  }\n  this.format();\n  return this;\n};\n\nexports.inc = inc;\nfunction inc(version, release, loose) {\n  try {\n    return new SemVer(version, loose).inc(release).version;\n  } catch (er) {\n    return null;\n  }\n}\n\nexports.compareIdentifiers = compareIdentifiers;\n\nvar numeric = /^[0-9]+$/;\nfunction compareIdentifiers(a, b) {\n  var anum = numeric.test(a);\n  var bnum = numeric.test(b);\n\n  if (anum && bnum) {\n    a = +a;\n    b = +b;\n  }\n\n  return (anum && !bnum) ? -1 :\n         (bnum && !anum) ? 1 :\n         a < b ? -1 :\n         a > b ? 1 :\n         0;\n}\n\nexports.rcompareIdentifiers = rcompareIdentifiers;\nfunction rcompareIdentifiers(a, b) {\n  return compareIdentifiers(b, a);\n}\n\nexports.compare = compare;\nfunction compare(a, b, loose) {\n  return new SemVer(a, loose).compare(b);\n}\n\nexports.compareLoose = compareLoose;\nfunction compareLoose(a, b) {\n  return compare(a, b, true);\n}\n\nexports.rcompare = rcompare;\nfunction rcompare(a, b, loose) {\n  return compare(b, a, loose);\n}\n\nexports.sort = sort;\nfunction sort(list, loose) {\n  return list.sort(function(a, b) {\n    return exports.compare(a, b, loose);\n  });\n}\n\nexports.rsort = rsort;\nfunction rsort(list, loose) {\n  return list.sort(function(a, b) {\n    return exports.rcompare(a, b, loose);\n  });\n}\n\nexports.gt = gt;\nfunction gt(a, b, loose) {\n  return compare(a, b, loose) > 0;\n}\n\nexports.lt = lt;\nfunction lt(a, b, loose) {\n  return compare(a, b, loose) < 0;\n}\n\nexports.eq = eq;\nfunction eq(a, b, loose) {\n  return compare(a, b, loose) === 0;\n}\n\nexports.neq = neq;\nfunction neq(a, b, loose) {\n  return compare(a, b, loose) !== 0;\n}\n\nexports.gte = gte;\nfunction gte(a, b, loose) {\n  return compare(a, b, loose) >= 0;\n}\n\nexports.lte = lte;\nfunction lte(a, b, loose) {\n  return compare(a, b, loose) <= 0;\n}\n\nexports.cmp = cmp;\nfunction cmp(a, op, b, loose) {\n  var ret;\n  switch (op) {\n    case '===': ret = a === b; break;\n    case '!==': ret = a !== b; break;\n    case '': case '=': case '==': ret = eq(a, b, loose); break;\n    case '!=': ret = neq(a, b, loose); break;\n    case '>': ret = gt(a, b, loose); break;\n    case '>=': ret = gte(a, b, loose); break;\n    case '<': ret = lt(a, b, loose); break;\n    case '<=': ret = lte(a, b, loose); break;\n    default: throw new TypeError('Invalid operator: ' + op);\n  }\n  return ret;\n}\n\nexports.Comparator = Comparator;\nfunction Comparator(comp, loose) {\n  if (comp instanceof Comparator) {\n    if (comp.loose === loose)\n      return comp;\n    else\n      comp = comp.value;\n  }\n\n  if (!(this instanceof Comparator))\n    return new Comparator(comp, loose);\n\n  debug('comparator', comp, loose);\n  this.loose = loose;\n  this.parse(comp);\n\n  if (this.semver === ANY)\n    this.value = '';\n  else\n    this.value = this.operator + this.semver.version;\n}\n\nvar ANY = {};\nComparator.prototype.parse = function(comp) {\n  var r = this.loose ? re[COMPARATORLOOSE] : re[COMPARATOR];\n  var m = comp.match(r);\n\n  if (!m)\n    throw new TypeError('Invalid comparator: ' + comp);\n\n  this.operator = m[1];\n  if (this.operator === '=')\n    this.operator = '';\n\n  // if it literally is just '>' or '' then allow anything.\n  if (!m[2])\n    this.semver = ANY;\n  else {\n    this.semver = new SemVer(m[2], this.loose);\n\n    // <1.2.3-rc DOES allow 1.2.3-beta (has prerelease)\n    // >=1.2.3 DOES NOT allow 1.2.3-beta\n    // <=1.2.3 DOES allow 1.2.3-beta\n    // However, <1.2.3 does NOT allow 1.2.3-beta,\n    // even though `1.2.3-beta < 1.2.3`\n    // The assumption is that the 1.2.3 version has something you\n    // *don't* want, so we push the prerelease down to the minimum.\n    if (this.operator === '<' && !this.semver.prerelease.length) {\n      this.semver.prerelease = ['0'];\n      this.semver.format();\n    }\n  }\n};\n\nComparator.prototype.inspect = function() {\n  return '<SemVer Comparator \"' + this + '\">';\n};\n\nComparator.prototype.toString = function() {\n  return this.value;\n};\n\nComparator.prototype.test = function(version) {\n  debug('Comparator.test', version, this.loose);\n  return (this.semver === ANY) ? true :\n         cmp(version, this.operator, this.semver, this.loose);\n};\n\n\nexports.Range = Range;\nfunction Range(range, loose) {\n  if ((range instanceof Range) && range.loose === loose)\n    return range;\n\n  if (!(this instanceof Range))\n    return new Range(range, loose);\n\n  this.loose = loose;\n\n  // First, split based on boolean or ||\n  this.raw = range;\n  this.set = range.split(/\\s*\\|\\|\\s*/).map(function(range) {\n    return this.parseRange(range.trim());\n  }, this).filter(function(c) {\n    // throw out any that are not relevant for whatever reason\n    return c.length;\n  });\n\n  if (!this.set.length) {\n    throw new TypeError('Invalid SemVer Range: ' + range);\n  }\n\n  this.format();\n}\n\nRange.prototype.inspect = function() {\n  return '<SemVer Range \"' + this.range + '\">';\n};\n\nRange.prototype.format = function() {\n  this.range = this.set.map(function(comps) {\n    return comps.join(' ').trim();\n  }).join('||').trim();\n  return this.range;\n};\n\nRange.prototype.toString = function() {\n  return this.range;\n};\n\nRange.prototype.parseRange = function(range) {\n  var loose = this.loose;\n  range = range.trim();\n  debug('range', range, loose);\n  // `1.2.3 - 1.2.4` => `>=1.2.3 <=1.2.4`\n  var hr = loose ? re[HYPHENRANGELOOSE] : re[HYPHENRANGE];\n  range = range.replace(hr, hyphenReplace);\n  debug('hyphen replace', range);\n  // `> 1.2.3 < 1.2.5` => `>1.2.3 <1.2.5`\n  range = range.replace(re[COMPARATORTRIM], comparatorTrimReplace);\n  debug('comparator trim', range, re[COMPARATORTRIM]);\n\n  // `~ 1.2.3` => `~1.2.3`\n  range = range.replace(re[TILDETRIM], tildeTrimReplace);\n\n  // `^ 1.2.3` => `^1.2.3`\n  range = range.replace(re[CARETTRIM], caretTrimReplace);\n\n  // normalize spaces\n  range = range.split(/\\s+/).join(' ');\n\n  // At this point, the range is completely trimmed and\n  // ready to be split into comparators.\n\n  var compRe = loose ? re[COMPARATORLOOSE] : re[COMPARATOR];\n  var set = range.split(' ').map(function(comp) {\n    return parseComparator(comp, loose);\n  }).join(' ').split(/\\s+/);\n  if (this.loose) {\n    // in loose mode, throw out any that are not valid comparators\n    set = set.filter(function(comp) {\n      return !!comp.match(compRe);\n    });\n  }\n  set = set.map(function(comp) {\n    return new Comparator(comp, loose);\n  });\n\n  return set;\n};\n\n// Mostly just for testing and legacy API reasons\nexports.toComparators = toComparators;\nfunction toComparators(range, loose) {\n  return new Range(range, loose).set.map(function(comp) {\n    return comp.map(function(c) {\n      return c.value;\n    }).join(' ').trim().split(' ');\n  });\n}\n\n// comprised of xranges, tildes, stars, and gtlt's at this point.\n// already replaced the hyphen ranges\n// turn into a set of JUST comparators.\nfunction parseComparator(comp, loose) {\n  debug('comp', comp);\n  comp = replaceCarets(comp, loose);\n  debug('caret', comp);\n  comp = replaceTildes(comp, loose);\n  debug('tildes', comp);\n  comp = replaceXRanges(comp, loose);\n  debug('xrange', comp);\n  comp = replaceStars(comp, loose);\n  debug('stars', comp);\n  return comp;\n}\n\nfunction isX(id) {\n  return !id || id.toLowerCase() === 'x' || id === '*';\n}\n\n// ~, ~> --> * (any, kinda silly)\n// ~2, ~2.x, ~2.x.x, ~>2, ~>2.x ~>2.x.x --> >=2.0.0 <3.0.0\n// ~2.0, ~2.0.x, ~>2.0, ~>2.0.x --> >=2.0.0 <2.1.0\n// ~1.2, ~1.2.x, ~>1.2, ~>1.2.x --> >=1.2.0 <1.3.0\n// ~1.2.3, ~>1.2.3 --> >=1.2.3 <1.3.0\n// ~1.2.0, ~>1.2.0 --> >=1.2.0 <1.3.0\nfunction replaceTildes(comp, loose) {\n  return comp.trim().split(/\\s+/).map(function(comp) {\n    return replaceTilde(comp, loose);\n  }).join(' ');\n}\n\nfunction replaceTilde(comp, loose) {\n  var r = loose ? re[TILDELOOSE] : re[TILDE];\n  return comp.replace(r, function(_, M, m, p, pr) {\n    debug('tilde', comp, _, M, m, p, pr);\n    var ret;\n\n    if (isX(M))\n      ret = '';\n    else if (isX(m))\n      ret = '>=' + M + '.0.0-0 <' + (+M + 1) + '.0.0-0';\n    else if (isX(p))\n      // ~1.2 == >=1.2.0- <1.3.0-\n      ret = '>=' + M + '.' + m + '.0-0 <' + M + '.' + (+m + 1) + '.0-0';\n    else if (pr) {\n      debug('replaceTilde pr', pr);\n      if (pr.charAt(0) !== '-')\n        pr = '-' + pr;\n      ret = '>=' + M + '.' + m + '.' + p + pr +\n            ' <' + M + '.' + (+m + 1) + '.0-0';\n    } else\n      // ~1.2.3 == >=1.2.3-0 <1.3.0-0\n      ret = '>=' + M + '.' + m + '.' + p + '-0' +\n            ' <' + M + '.' + (+m + 1) + '.0-0';\n\n    debug('tilde return', ret);\n    return ret;\n  });\n}\n\n// ^ --> * (any, kinda silly)\n// ^2, ^2.x, ^2.x.x --> >=2.0.0 <3.0.0\n// ^2.0, ^2.0.x --> >=2.0.0 <3.0.0\n// ^1.2, ^1.2.x --> >=1.2.0 <2.0.0\n// ^1.2.3 --> >=1.2.3 <2.0.0\n// ^1.2.0 --> >=1.2.0 <2.0.0\nfunction replaceCarets(comp, loose) {\n  return comp.trim().split(/\\s+/).map(function(comp) {\n    return replaceCaret(comp, loose);\n  }).join(' ');\n}\n\nfunction replaceCaret(comp, loose) {\n  var r = loose ? re[CARETLOOSE] : re[CARET];\n  return comp.replace(r, function(_, M, m, p, pr) {\n    debug('caret', comp, _, M, m, p, pr);\n    var ret;\n\n    if (isX(M))\n      ret = '';\n    else if (isX(m))\n      ret = '>=' + M + '.0.0-0 <' + (+M + 1) + '.0.0-0';\n    else if (isX(p)) {\n      if (M === '0')\n        ret = '>=' + M + '.' + m + '.0-0 <' + M + '.' + (+m + 1) + '.0-0';\n      else\n        ret = '>=' + M + '.' + m + '.0-0 <' + (+M + 1) + '.0.0-0';\n    } else if (pr) {\n      debug('replaceCaret pr', pr);\n      if (pr.charAt(0) !== '-')\n        pr = '-' + pr;\n      if (M === '0') {\n        if (m === '0')\n          ret = '=' + M + '.' + m + '.' + p + pr;\n        else\n          ret = '>=' + M + '.' + m + '.' + p + pr +\n                ' <' + M + '.' + (+m + 1) + '.0-0';\n      } else\n        ret = '>=' + M + '.' + m + '.' + p + pr +\n              ' <' + (+M + 1) + '.0.0-0';\n    } else {\n      if (M === '0') {\n        if (m === '0')\n          ret = '=' + M + '.' + m + '.' + p;\n        else\n          ret = '>=' + M + '.' + m + '.' + p + '-0' +\n                ' <' + M + '.' + (+m + 1) + '.0-0';\n      } else\n        ret = '>=' + M + '.' + m + '.' + p + '-0' +\n              ' <' + (+M + 1) + '.0.0-0';\n    }\n\n    debug('caret return', ret);\n    return ret;\n  });\n}\n\nfunction replaceXRanges(comp, loose) {\n  debug('replaceXRanges', comp, loose);\n  return comp.split(/\\s+/).map(function(comp) {\n    return replaceXRange(comp, loose);\n  }).join(' ');\n}\n\nfunction replaceXRange(comp, loose) {\n  comp = comp.trim();\n  var r = loose ? re[XRANGELOOSE] : re[XRANGE];\n  return comp.replace(r, function(ret, gtlt, M, m, p, pr) {\n    debug('xRange', comp, ret, gtlt, M, m, p, pr);\n    var xM = isX(M);\n    var xm = xM || isX(m);\n    var xp = xm || isX(p);\n    var anyX = xp;\n\n    if (gtlt === '=' && anyX)\n      gtlt = '';\n\n    if (gtlt && anyX) {\n      // replace X with 0, and then append the -0 min-prerelease\n      if (xM)\n        M = 0;\n      if (xm)\n        m = 0;\n      if (xp)\n        p = 0;\n\n      if (gtlt === '>') {\n        // >1 => >=2.0.0-0\n        // >1.2 => >=1.3.0-0\n        // >1.2.3 => >= 1.2.4-0\n        gtlt = '>=';\n        if (xM) {\n          // no change\n        } else if (xm) {\n          M = +M + 1;\n          m = 0;\n          p = 0;\n        } else if (xp) {\n          m = +m + 1;\n          p = 0;\n        }\n      }\n\n\n      ret = gtlt + M + '.' + m + '.' + p + '-0';\n    } else if (xM) {\n      // allow any\n      ret = '*';\n    } else if (xm) {\n      // append '-0' onto the version, otherwise\n      // '1.x.x' matches '2.0.0-beta', since the tag\n      // *lowers* the version value\n      ret = '>=' + M + '.0.0-0 <' + (+M + 1) + '.0.0-0';\n    } else if (xp) {\n      ret = '>=' + M + '.' + m + '.0-0 <' + M + '.' + (+m + 1) + '.0-0';\n    }\n\n    debug('xRange return', ret);\n\n    return ret;\n  });\n}\n\n// Because * is AND-ed with everything else in the comparator,\n// and '' means \"any version\", just remove the *s entirely.\nfunction replaceStars(comp, loose) {\n  debug('replaceStars', comp, loose);\n  // Looseness is ignored here.  star is always as loose as it gets!\n  return comp.trim().replace(re[STAR], '');\n}\n\n// This function is passed to string.replace(re[HYPHENRANGE])\n// M, m, patch, prerelease, build\n// 1.2 - 3.4.5 => >=1.2.0-0 <=3.4.5\n// 1.2.3 - 3.4 => >=1.2.0-0 <3.5.0-0 Any 3.4.x will do\n// 1.2 - 3.4 => >=1.2.0-0 <3.5.0-0\nfunction hyphenReplace($0,\n                       from, fM, fm, fp, fpr, fb,\n                       to, tM, tm, tp, tpr, tb) {\n\n  if (isX(fM))\n    from = '';\n  else if (isX(fm))\n    from = '>=' + fM + '.0.0-0';\n  else if (isX(fp))\n    from = '>=' + fM + '.' + fm + '.0-0';\n  else\n    from = '>=' + from;\n\n  if (isX(tM))\n    to = '';\n  else if (isX(tm))\n    to = '<' + (+tM + 1) + '.0.0-0';\n  else if (isX(tp))\n    to = '<' + tM + '.' + (+tm + 1) + '.0-0';\n  else if (tpr)\n    to = '<=' + tM + '.' + tm + '.' + tp + '-' + tpr;\n  else\n    to = '<=' + to;\n\n  return (from + ' ' + to).trim();\n}\n\n\n// if ANY of the sets match ALL of its comparators, then pass\nRange.prototype.test = function(version) {\n  if (!version)\n    return false;\n  for (var i = 0; i < this.set.length; i++) {\n    if (testSet(this.set[i], version))\n      return true;\n  }\n  return false;\n};\n\nfunction testSet(set, version) {\n  for (var i = 0; i < set.length; i++) {\n    if (!set[i].test(version))\n      return false;\n  }\n  return true;\n}\n\nexports.satisfies = satisfies;\nfunction satisfies(version, range, loose) {\n  try {\n    range = new Range(range, loose);\n  } catch (er) {\n    return false;\n  }\n  return range.test(version);\n}\n\nexports.maxSatisfying = maxSatisfying;\nfunction maxSatisfying(versions, range, loose) {\n  return versions.filter(function(version) {\n    return satisfies(version, range, loose);\n  }).sort(function(a, b) {\n    return rcompare(a, b, loose);\n  })[0] || null;\n}\n\nexports.validRange = validRange;\nfunction validRange(range, loose) {\n  try {\n    // Return '*' instead of '' so that truthiness works.\n    // This will throw if it's invalid anyway\n    return new Range(range, loose).range || '*';\n  } catch (er) {\n    return null;\n  }\n}\n\n// Determine if version is less than all the versions possible in the range\nexports.ltr = ltr;\nfunction ltr(version, range, loose) {\n  return outside(version, range, '<', loose);\n}\n\n// Determine if version is greater than all the versions possible in the range.\nexports.gtr = gtr;\nfunction gtr(version, range, loose) {\n  return outside(version, range, '>', loose);\n}\n\nexports.outside = outside;\nfunction outside(version, range, hilo, loose) {\n  version = new SemVer(version, loose);\n  range = new Range(range, loose);\n\n  var gtfn, ltefn, ltfn, comp, ecomp;\n  switch (hilo) {\n    case '>':\n      gtfn = gt;\n      ltefn = lte;\n      ltfn = lt;\n      comp = '>';\n      ecomp = '>=';\n      break;\n    case '<':\n      gtfn = lt;\n      ltefn = gte;\n      ltfn = gt;\n      comp = '<';\n      ecomp = '<=';\n      break;\n    default:\n      throw new TypeError('Must provide a hilo val of \"<\" or \">\"');\n  }\n\n  // If it satisifes the range it is not outside\n  if (satisfies(version, range, loose)) {\n    return false;\n  }\n\n  // From now on, variable terms are as if we're in \"gtr\" mode.\n  // but note that everything is flipped for the \"ltr\" function.\n\n  for (var i = 0; i < range.set.length; ++i) {\n    var comparators = range.set[i];\n\n    var high = null;\n    var low = null;\n\n    comparators.forEach(function(comparator) {\n      high = high || comparator;\n      low = low || comparator;\n      if (gtfn(comparator.semver, high.semver, loose)) {\n        high = comparator;\n      } else if (ltfn(comparator.semver, low.semver, loose)) {\n        low = comparator;\n      }\n    });\n\n    // If the edge version comparator has a operator then our version\n    // isn't outside it\n    if (high.operator === comp || high.operator === ecomp) {\n      return false;\n    }\n\n    // If the lowest version comparator has an operator and our version\n    // is less than it then it isn't higher than the range\n    if ((!low.operator || low.operator === comp) &&\n        ltefn(version, low.semver)) {\n      return false;\n    } else if (low.operator === ecomp && ltfn(version, low.semver)) {\n      return false;\n    }\n  }\n  return true;\n}\n\n// Use the define() function if we're in AMD land\nif (typeof define === 'function' && define.amd)\n  define(exports);\n","/home/travis/build/npmtest/node-npmtest-spm/node_modules/spm-client/lib/search.js":"'use strict';\n\nvar extend = require('extend');\nvar format = require('util').format;\nvar request = require('./request');\nvar util = require('./util');\nvar debug = require('debug')('spm-client:search');\n\n/*\n  info(args, config)\n\n  * args\n    * name: search packages with your query name\n  * config: see client.config\n*/\n\nmodule.exports = function* search(args, config) {\n  args = extend({}, require('./config')(), config, args);\n\n  var req = {};\n  req.url = format('%s/repository/search?q=%s', args.registry, args.name);\n  req.method = 'GET';\n  req.json = true;\n\n  debug('search package with %s', args.name);\n  var res = yield* request(req);\n  util.errorHandle(req, res);\n  return res.body;\n};\n","/home/travis/build/npmtest/node-npmtest-spm/node_modules/spm/lib/upload.js":"var fs = require('fs');\nvar path = require('path');\nvar format = require('util').format;\nvar tar = require('./utils/tar');\nvar log = require('spm-log');\nvar readJSON = require('fs-extra').readJSONSync;\nvar yuan = require('./sdk/yuan');\nvar spmrc = require('spmrc');\n\nmodule.exports = function upload(options, callback) {\n  var doc = options.doc || '_site';\n  log.info('upload', doc);\n  var pkg = readJSON('package.json');\n  _createTar(doc, pkg, function(err, target) {\n    pkg.tarfile = target;\n    pkg.tag = options.tag;\n    yuan(options).upload(pkg, function(err, res, body) {\n      if (err) {\n        log.error('exit', err);\n        process.exit(1);\n      }\n      if (res.statusCode >= 400) {\n        log.error('exit', res.statusCode);\n      }\n      if (typeof body === 'string') {\n        body = JSON.parse(body);\n      }\n      if (body.message && body.status) {\n        log[body.status](body.status, body.message);\n      }\n      console.log();\n      if (callback) callback();\n    });\n  }, true);\n};\n\nfunction _createTar(directory, data, callback, noIgnore) {\n  var name = format('%s-%s.tar.gz', data.name, data.version || '');\n  var tmp = spmrc.get('user.temp');\n  var tarfile = path.join(tmp, name);\n  tar.create(directory, tarfile, function(error, target) {\n    var size = fs.statSync(target).size;\n    log.info('tarfile', name + ' - ' + ((size/1024).toFixed(2) + 'KB').to.magenta);\n    // 2 MB\n    if (size > 2079152) {\n      log.warn('size', 'package is a little big, maybe you need a .spmignore');\n    }\n    if (error) {\n      log.error('exit', error);\n      process.exit(1);\n    }\n    log.debug('tarfile', target);\n    callback(null, target);\n  }, noIgnore);\n}\n","/home/travis/build/npmtest/node-npmtest-spm/node_modules/spm/lib/utils/tar.js":"// Thanks to npm.\nvar fstream = require('fstream');\nvar tar = require('tar');\nvar zlib = require('zlib');\nvar path = require('path');\nvar fs = require('fs');\nvar log = require('spm-log');\n\nvar myUid = process.getuid && process.getuid();\nvar myGid = process.getgid && process.getgid();\n\nif (process.env.SUDO_UID && myUid === 0) {\n  if (!isNaN(process.env.SUDO_UID)) {\n    myUid = +process.env.SUDO_UID;\n  }\n  if (!isNaN(process.env.SUDO_GID)) {\n    myGid = +process.env.SUDO_GID;\n  }\n}\n\nexports.create = function(source, target, callback, noIgnore) {\n  function returnError(err) {\n    // don't call the callback multiple times, just return the first error\n    var _callback = callback;\n    callback = function() {};\n    return _callback(err);\n  }\n\n  var fwriter = fstream.Writer({ type: 'File', path: target });\n  fwriter.on('error', function(err) {\n    log.error('writing', target);\n    return returnError(err);\n  });\n\n  fwriter.on('close', function() {\n    callback(null, target);\n  });\n\n  var pkg = JSON.parse(fs.readFileSync(path.join(source, 'package.json')));\n  var ignoreArray;\n  if (pkg && pkg.spm && pkg.spm.ignore) {\n    ignoreArray = pkg.spm.ignore;\n  } else {\n    ignoreArray = [];\n  }\n  var ignoreFiles = ['.gitignore', '.spmignore'];\n\n  if (noIgnore) {\n    ignoreFiles = [];\n    ignoreArray = []; // always ignore dist when noIgnore\n  }\n\n  var istream = new Packer({\n    path: source,\n    type: 'Directory',\n    ignoreFiles: ignoreFiles,\n    ignoreArray: ignoreArray,\n    isDirectory: true\n  });\n  istream.on('error', function(err) {\n    log.error('reading', source);\n    return returnError(err);\n  });\n\n  var packer = tar.Pack({ noProprietary: true });\n  packer.on('error', function(err) {\n    log.error('creating', target);\n    return returnError(err);\n  });\n\n  var zipper = zlib.Gzip();\n  zipper.on('error', function(err) {\n    log.error('gzip', target);\n    return returnError(err);\n  });\n\n  istream.pipe(packer).pipe(zipper).pipe(fwriter);\n};\n\n\nvar Ignore = require('fstream-ignore');\nvar inherits = require('inherits');\n\nfunction Packer(props) {\n  if (!(this instanceof Packer)) {\n    return new Packer(props);\n  }\n\n  if (typeof props === 'string') {\n    props = { path: props };\n  }\n\n  props.ignoreFiles = props.ignoreFiles || [];\n  props.ignoreArray = props.ignoreArray || [];\n\n  Ignore.call(this, props);\n  Ignore.prototype.addIgnoreRules.call(this, props.ignoreArray, '');\n\n  this.on('entryStat', function(entry, props) {\n    // files should *always* get into tarballs\n    // in a user-writable state, even if they're\n    // being installed from some wackey vm-mounted\n    // read-only filesystem.\n    entry.mode = props.mode = props.mode | 0200;\n  });\n}\n\nPacker.prototype.applyIgnores = function(entry, partial, entryObj) {\n\n  // some files are *never* allowed under any circumstances\n  if (entry === '.git' ||\n      entry === '.lock-wscript' ||\n      entry.match(/^\\.wafpickle-[0-9]+$/) ||\n      entry === 'CVS' ||\n      entry === '.svn' ||\n      entry === '.hg' ||\n      entry.match(/^\\..*\\.swp$/) ||\n      entry === '.DS_Store' ||\n      entry.match(/^\\._/)\n    ) {\n    return false;\n  }\n\n  // package.json should be **allways** included\n  if (entry === 'package.json') {\n    return true;\n  }\n\n  return Ignore.prototype.applyIgnores.call(this, entry, partial, entryObj);\n};\n\nPacker.prototype.emitEntry = function(entry) {\n  if (this._paused) {\n    this.once('resume', this.emitEntry.bind(this, entry));\n    return;\n  }\n\n  // skip over symbolic links\n  if (entry.type === 'SymbolicLink') {\n    entry.abort();\n    return;\n  }\n\n  // files in the root directory of the tarball\n  if (entry.type !== 'Directory') {\n    var h = path.dirname((entry.root || entry).path);\n    var t = entry.path.substr(h.length + 1).replace(/^[^\\/\\\\]+/, '');\n    var p = h + '/' + t.replace(/^\\//, '');\n    entry.path = p;\n    entry.dirname = path.dirname(p);\n    return Ignore.prototype.emitEntry.call(this, entry);\n  }\n\n  // don't pack empty directories\n  var me = this;\n  entry.on('entry', function(e) {\n    if (e.parent === entry) {\n      e.parent = me;\n      me.emit('entry', e);\n    }\n  });\n  entry.on('package', this.emit.bind(this, 'package'));\n};\n\ninherits(Packer, Ignore);\n","/home/travis/build/npmtest/node-npmtest-spm/node_modules/spm/lib/sdk/yuan.js":"\nvar fs = require('fs');\nvar os = require('os');\nvar zlib = require('zlib');\nvar request = require('request');\nvar util = require('util');\nvar spmrc = require('spmrc');\nvar log = require('spm-log');\nvar pkg = require('../../package.json');\n\nvar userAgent = util.format(\n  'spm (%s, %s, %s %s)',\n  pkg.version, process.version, os.platform(), os.arch()\n);\n\nfunction Yuan(options) {\n  options = options || {};\n\n  this.server = options.registry || spmrc.get('registry') || 'http://spmjs.io';\n  this.server = this.server.replace(/\\/$/, '');\n  options.proxy = options.proxy || spmrc.get('proxy');\n\n  this.authKey = 'auth';\n  this.options = options;\n}\n\nYuan.prototype.request = function(data, callback) {\n  callback = callback || function() {};\n\n  data.url = util.format('%s/%s', this.server, data.urlpath);\n  log.debug(data.method.toLowerCase(), data.url);\n\n  data.headers = data.headers || {};\n\n  if (data.auth) {\n    data.headers['Authorization'] = 'Yuan ' + data.auth;\n    delete data.auth;\n  }\n  var options = this.options;\n  if (options.force) {\n    data.headers['X-Yuan-Force'] = 'true';\n  }\n  data.headers['user-agent'] = userAgent;\n\n  if (options.lang) {\n    data.headers['Accept-Language'] = options.lang;\n  } else {\n    data.headers['Accept-Language'] = process.env.LANG || 'en_US';\n  }\n\n  if (options.proxy) {\n    data.proxy = options.proxy;\n  }\n\n  // use gzip\n  if (data.json) {\n    data.encoding = null;\n    data.headers['accept-encoding'] = 'gzip';\n  }\n\n  var self = this;\n  var req = request(data, function(err, res, body) {\n    if (err) {\n      if (err.code === 'ECONNREFUSED' || err.code === 'ENOTFOUND') {\n        log.error('request', err);\n        log.error('yuan', data.url);\n        process.exit(1);\n      }\n      callback(err);\n      return;\n    }\n    if (data.json && res.headers['content-encoding'] === 'gzip') {\n      zlib.gunzip(body, function(err, content) {\n        if (err) {\n          callback(err);\n          return;\n        }\n        try {\n          body = JSON.parse(content.toString());\n        } catch(e) {\n          log.error('yuan', 'parsing response error');\n          log.debug('html', content);\n          process.exit(2);\n        }\n        res.body = body;\n        callback(err, res, body);\n      });\n    } else {\n      callback(err, res, body);\n    }\n  });\n\n  req.on('error', function(err) {\n    log.error('error', err);\n  });\n  req.on('complete', function(res) {\n    if (res.statusCode === 401) {\n      log.error('fail', 'authorization is required. try `spm login`');\n      spmrc.set(self.authKey, '');\n      process.exit(1);\n    }\n  });\n  return req;\n};\n\nYuan.prototype.upload = function(data, callback) {\n  if (data.private && this.server === 'http://spmjs.io') {\n    log.error('yuan', 'this is a private repo');\n    process.exit(3);\n  }\n\n  var auth = spmrc.get(this.authKey);\n  var query = {\n    urlpath: 'repository/upload/',\n    method: 'POST',\n    auth: auth\n  };\n  var self = this;\n  var r = this.request(query, callback);\n\n  var form = r.form();\n  form.append('name', data.name || '');\n  form.append('version', data.version || '');\n  form.append('tag', data.tag || 'latest');\n  form.append('file', fs.createReadStream(data.tarfile));\n  form.getLength(function(err, len) {\n    log.info('target', self.server);\n    r.setHeader('Content-Length', len);\n  });\n};\n\nexports = module.exports = function(options) {\n  return new Yuan(options);\n};\n\nexports.Yuan = Yuan;\n"}